// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`CLI options testing generation with \`config.example.js\` 1`] = `
import { apiClient } from '../fixtures/emptyApi';
export const listAppthrustDevV1AlbGatewayParametersForAllNamespaces = (
  args: ListAppthrustDevV1AlbGatewayParametersForAllNamespacesApiArg
): Promise<ListAppthrustDevV1AlbGatewayParametersForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/albgatewayparameterses\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1AwsRoute53ZoneForAllNamespaces = (
  args: ListAppthrustDevV1AwsRoute53ZoneForAllNamespacesApiArg
): Promise<ListAppthrustDevV1AwsRoute53ZoneForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/awsroute53zones\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1CertForAllNamespaces = (
  args: ListAppthrustDevV1CertForAllNamespacesApiArg
): Promise<ListAppthrustDevV1CertForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/certs\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1ContainerImageTagForAllNamespaces = (
  args: ListAppthrustDevV1ContainerImageTagForAllNamespacesApiArg
): Promise<ListAppthrustDevV1ContainerImageTagForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/containerimagetags\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1ContainerRepositoryForAllNamespaces = (
  args: ListAppthrustDevV1ContainerRepositoryForAllNamespacesApiArg
): Promise<ListAppthrustDevV1ContainerRepositoryForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/containerrepositories\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1DnsZoneForAllNamespaces = (
  args: ListAppthrustDevV1DnsZoneForAllNamespacesApiArg
): Promise<ListAppthrustDevV1DnsZoneForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/dnszones\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1DnsZoneTransferForAllNamespaces = (
  args: ListAppthrustDevV1DnsZoneTransferForAllNamespacesApiArg
): Promise<ListAppthrustDevV1DnsZoneTransferForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/dnszonetransfers\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1DomainForAllNamespaces = (
  args: ListAppthrustDevV1DomainForAllNamespacesApiArg
): Promise<ListAppthrustDevV1DomainForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/domains\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1EksForAllNamespaces = (
  args: ListAppthrustDevV1EksForAllNamespacesApiArg
): Promise<ListAppthrustDevV1EksForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/eks\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1HttprouteToIngressForAllNamespaces = (
  args: ListAppthrustDevV1HttprouteToIngressForAllNamespacesApiArg
): Promise<ListAppthrustDevV1HttprouteToIngressForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/httproutetoingresses\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1IamDataForAllNamespaces = (
  args: ListAppthrustDevV1IamDataForAllNamespacesApiArg
): Promise<ListAppthrustDevV1IamDataForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/iamdatas\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1IamForAllNamespaces = (
  args: ListAppthrustDevV1IamForAllNamespacesApiArg
): Promise<ListAppthrustDevV1IamForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/iams\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1KeycloakClientSecretForAllNamespaces = (
  args: ListAppthrustDevV1KeycloakClientSecretForAllNamespacesApiArg
): Promise<ListAppthrustDevV1KeycloakClientSecretForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/keycloakclientsecrets\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1KeycloakKeyIdForAllNamespaces = (
  args: ListAppthrustDevV1KeycloakKeyIdForAllNamespacesApiArg
): Promise<ListAppthrustDevV1KeycloakKeyIdForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/keycloakkeyids\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1KeycloakPasswordInitForAllNamespaces = (
  args: ListAppthrustDevV1KeycloakPasswordInitForAllNamespacesApiArg
): Promise<ListAppthrustDevV1KeycloakPasswordInitForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/keycloakpasswordinits\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1NamespacedAlbGatewayParameters = (
  args: ListAppthrustDevV1NamespacedAlbGatewayParametersApiArg
): Promise<ListAppthrustDevV1NamespacedAlbGatewayParametersApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedAlbGatewayParameters = (
  args: CreateAppthrustDevV1NamespacedAlbGatewayParametersApiArg
): Promise<CreateAppthrustDevV1NamespacedAlbGatewayParametersApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses\`,
    method: 'POST',
    body: args.devAppthrustV1AlbGatewayParameters,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedAlbGatewayParameters = (
  args: DeleteAppthrustDevV1CollectionNamespacedAlbGatewayParametersApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedAlbGatewayParametersApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedAlbGatewayParameters = (
  args: ReadAppthrustDevV1NamespacedAlbGatewayParametersApiArg
): Promise<ReadAppthrustDevV1NamespacedAlbGatewayParametersApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedAlbGatewayParameters = (
  args: ReplaceAppthrustDevV1NamespacedAlbGatewayParametersApiArg
): Promise<ReplaceAppthrustDevV1NamespacedAlbGatewayParametersApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1AlbGatewayParameters,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedAlbGatewayParameters = (
  args: DeleteAppthrustDevV1NamespacedAlbGatewayParametersApiArg
): Promise<DeleteAppthrustDevV1NamespacedAlbGatewayParametersApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedAlbGatewayParameters = (
  args: PatchAppthrustDevV1NamespacedAlbGatewayParametersApiArg
): Promise<PatchAppthrustDevV1NamespacedAlbGatewayParametersApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedAlbGatewayParametersStatus = (
  args: ReadAppthrustDevV1NamespacedAlbGatewayParametersStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedAlbGatewayParametersStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedAlbGatewayParametersStatus = (
  args: ReplaceAppthrustDevV1NamespacedAlbGatewayParametersStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedAlbGatewayParametersStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1AlbGatewayParameters,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedAlbGatewayParametersStatus = (
  args: PatchAppthrustDevV1NamespacedAlbGatewayParametersStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedAlbGatewayParametersStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedAwsRoute53Zone = (
  args: ListAppthrustDevV1NamespacedAwsRoute53ZoneApiArg
): Promise<ListAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedAwsRoute53Zone = (
  args: CreateAppthrustDevV1NamespacedAwsRoute53ZoneApiArg
): Promise<CreateAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones\`,
    method: 'POST',
    body: args.devAppthrustV1AwsRoute53Zone,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedAwsRoute53Zone = (
  args: DeleteAppthrustDevV1CollectionNamespacedAwsRoute53ZoneApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedAwsRoute53ZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedAwsRoute53Zone = (
  args: ReadAppthrustDevV1NamespacedAwsRoute53ZoneApiArg
): Promise<ReadAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedAwsRoute53Zone = (
  args: ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneApiArg
): Promise<ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1AwsRoute53Zone,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedAwsRoute53Zone = (
  args: DeleteAppthrustDevV1NamespacedAwsRoute53ZoneApiArg
): Promise<DeleteAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedAwsRoute53Zone = (
  args: PatchAppthrustDevV1NamespacedAwsRoute53ZoneApiArg
): Promise<PatchAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedAwsRoute53ZoneStatus = (
  args: ReadAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedAwsRoute53ZoneStatus = (
  args: ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1AwsRoute53Zone,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedAwsRoute53ZoneStatus = (
  args: PatchAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedCert = (
  args: ListAppthrustDevV1NamespacedCertApiArg
): Promise<ListAppthrustDevV1NamespacedCertApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedCert = (
  args: CreateAppthrustDevV1NamespacedCertApiArg
): Promise<CreateAppthrustDevV1NamespacedCertApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs\`,
    method: 'POST',
    body: args.devAppthrustV1Cert,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedCert = (
  args: DeleteAppthrustDevV1CollectionNamespacedCertApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedCertApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedCert = (
  args: ReadAppthrustDevV1NamespacedCertApiArg
): Promise<ReadAppthrustDevV1NamespacedCertApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedCert = (
  args: ReplaceAppthrustDevV1NamespacedCertApiArg
): Promise<ReplaceAppthrustDevV1NamespacedCertApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1Cert,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedCert = (
  args: DeleteAppthrustDevV1NamespacedCertApiArg
): Promise<DeleteAppthrustDevV1NamespacedCertApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedCert = (
  args: PatchAppthrustDevV1NamespacedCertApiArg
): Promise<PatchAppthrustDevV1NamespacedCertApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedCertStatus = (
  args: ReadAppthrustDevV1NamespacedCertStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedCertStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedCertStatus = (
  args: ReplaceAppthrustDevV1NamespacedCertStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedCertStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1Cert,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedCertStatus = (
  args: PatchAppthrustDevV1NamespacedCertStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedCertStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedContainerImageTag = (
  args: ListAppthrustDevV1NamespacedContainerImageTagApiArg
): Promise<ListAppthrustDevV1NamespacedContainerImageTagApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedContainerImageTag = (
  args: CreateAppthrustDevV1NamespacedContainerImageTagApiArg
): Promise<CreateAppthrustDevV1NamespacedContainerImageTagApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags\`,
    method: 'POST',
    body: args.devAppthrustV1ContainerImageTag,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedContainerImageTag = (
  args: DeleteAppthrustDevV1CollectionNamespacedContainerImageTagApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedContainerImageTagApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedContainerImageTag = (
  args: ReadAppthrustDevV1NamespacedContainerImageTagApiArg
): Promise<ReadAppthrustDevV1NamespacedContainerImageTagApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedContainerImageTag = (
  args: ReplaceAppthrustDevV1NamespacedContainerImageTagApiArg
): Promise<ReplaceAppthrustDevV1NamespacedContainerImageTagApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1ContainerImageTag,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedContainerImageTag = (
  args: DeleteAppthrustDevV1NamespacedContainerImageTagApiArg
): Promise<DeleteAppthrustDevV1NamespacedContainerImageTagApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedContainerImageTag = (
  args: PatchAppthrustDevV1NamespacedContainerImageTagApiArg
): Promise<PatchAppthrustDevV1NamespacedContainerImageTagApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedContainerImageTagStatus = (
  args: ReadAppthrustDevV1NamespacedContainerImageTagStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedContainerImageTagStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedContainerImageTagStatus = (
  args: ReplaceAppthrustDevV1NamespacedContainerImageTagStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedContainerImageTagStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1ContainerImageTag,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedContainerImageTagStatus = (
  args: PatchAppthrustDevV1NamespacedContainerImageTagStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedContainerImageTagStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedContainerRepository = (
  args: ListAppthrustDevV1NamespacedContainerRepositoryApiArg
): Promise<ListAppthrustDevV1NamespacedContainerRepositoryApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedContainerRepository = (
  args: CreateAppthrustDevV1NamespacedContainerRepositoryApiArg
): Promise<CreateAppthrustDevV1NamespacedContainerRepositoryApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories\`,
    method: 'POST',
    body: args.devAppthrustV1ContainerRepository,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedContainerRepository = (
  args: DeleteAppthrustDevV1CollectionNamespacedContainerRepositoryApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedContainerRepositoryApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedContainerRepository = (
  args: ReadAppthrustDevV1NamespacedContainerRepositoryApiArg
): Promise<ReadAppthrustDevV1NamespacedContainerRepositoryApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedContainerRepository = (
  args: ReplaceAppthrustDevV1NamespacedContainerRepositoryApiArg
): Promise<ReplaceAppthrustDevV1NamespacedContainerRepositoryApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1ContainerRepository,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedContainerRepository = (
  args: DeleteAppthrustDevV1NamespacedContainerRepositoryApiArg
): Promise<DeleteAppthrustDevV1NamespacedContainerRepositoryApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedContainerRepository = (
  args: PatchAppthrustDevV1NamespacedContainerRepositoryApiArg
): Promise<PatchAppthrustDevV1NamespacedContainerRepositoryApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedContainerRepositoryStatus = (
  args: ReadAppthrustDevV1NamespacedContainerRepositoryStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedContainerRepositoryStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedContainerRepositoryStatus = (
  args: ReplaceAppthrustDevV1NamespacedContainerRepositoryStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedContainerRepositoryStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1ContainerRepository,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedContainerRepositoryStatus = (
  args: PatchAppthrustDevV1NamespacedContainerRepositoryStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedContainerRepositoryStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedDnsZone = (
  args: ListAppthrustDevV1NamespacedDnsZoneApiArg
): Promise<ListAppthrustDevV1NamespacedDnsZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedDnsZone = (
  args: CreateAppthrustDevV1NamespacedDnsZoneApiArg
): Promise<CreateAppthrustDevV1NamespacedDnsZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones\`,
    method: 'POST',
    body: args.devAppthrustV1DnsZone,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedDnsZone = (
  args: DeleteAppthrustDevV1CollectionNamespacedDnsZoneApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedDnsZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedDnsZone = (
  args: ReadAppthrustDevV1NamespacedDnsZoneApiArg
): Promise<ReadAppthrustDevV1NamespacedDnsZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedDnsZone = (
  args: ReplaceAppthrustDevV1NamespacedDnsZoneApiArg
): Promise<ReplaceAppthrustDevV1NamespacedDnsZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1DnsZone,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedDnsZone = (
  args: DeleteAppthrustDevV1NamespacedDnsZoneApiArg
): Promise<DeleteAppthrustDevV1NamespacedDnsZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedDnsZone = (
  args: PatchAppthrustDevV1NamespacedDnsZoneApiArg
): Promise<PatchAppthrustDevV1NamespacedDnsZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedDnsZoneStatus = (
  args: ReadAppthrustDevV1NamespacedDnsZoneStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedDnsZoneStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedDnsZoneStatus = (
  args: ReplaceAppthrustDevV1NamespacedDnsZoneStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedDnsZoneStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1DnsZone,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedDnsZoneStatus = (
  args: PatchAppthrustDevV1NamespacedDnsZoneStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedDnsZoneStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedDnsZoneTransfer = (
  args: ListAppthrustDevV1NamespacedDnsZoneTransferApiArg
): Promise<ListAppthrustDevV1NamespacedDnsZoneTransferApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedDnsZoneTransfer = (
  args: CreateAppthrustDevV1NamespacedDnsZoneTransferApiArg
): Promise<CreateAppthrustDevV1NamespacedDnsZoneTransferApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers\`,
    method: 'POST',
    body: args.devAppthrustV1DnsZoneTransfer,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedDnsZoneTransfer = (
  args: DeleteAppthrustDevV1CollectionNamespacedDnsZoneTransferApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedDnsZoneTransferApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedDnsZoneTransfer = (
  args: ReadAppthrustDevV1NamespacedDnsZoneTransferApiArg
): Promise<ReadAppthrustDevV1NamespacedDnsZoneTransferApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedDnsZoneTransfer = (
  args: ReplaceAppthrustDevV1NamespacedDnsZoneTransferApiArg
): Promise<ReplaceAppthrustDevV1NamespacedDnsZoneTransferApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1DnsZoneTransfer,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedDnsZoneTransfer = (
  args: DeleteAppthrustDevV1NamespacedDnsZoneTransferApiArg
): Promise<DeleteAppthrustDevV1NamespacedDnsZoneTransferApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedDnsZoneTransfer = (
  args: PatchAppthrustDevV1NamespacedDnsZoneTransferApiArg
): Promise<PatchAppthrustDevV1NamespacedDnsZoneTransferApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedDnsZoneTransferStatus = (
  args: ReadAppthrustDevV1NamespacedDnsZoneTransferStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedDnsZoneTransferStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedDnsZoneTransferStatus = (
  args: ReplaceAppthrustDevV1NamespacedDnsZoneTransferStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedDnsZoneTransferStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1DnsZoneTransfer,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedDnsZoneTransferStatus = (
  args: PatchAppthrustDevV1NamespacedDnsZoneTransferStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedDnsZoneTransferStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedDomain = (
  args: ListAppthrustDevV1NamespacedDomainApiArg
): Promise<ListAppthrustDevV1NamespacedDomainApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedDomain = (
  args: CreateAppthrustDevV1NamespacedDomainApiArg
): Promise<CreateAppthrustDevV1NamespacedDomainApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains\`,
    method: 'POST',
    body: args.devAppthrustV1Domain,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedDomain = (
  args: DeleteAppthrustDevV1CollectionNamespacedDomainApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedDomainApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedDomain = (
  args: ReadAppthrustDevV1NamespacedDomainApiArg
): Promise<ReadAppthrustDevV1NamespacedDomainApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedDomain = (
  args: ReplaceAppthrustDevV1NamespacedDomainApiArg
): Promise<ReplaceAppthrustDevV1NamespacedDomainApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1Domain,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedDomain = (
  args: DeleteAppthrustDevV1NamespacedDomainApiArg
): Promise<DeleteAppthrustDevV1NamespacedDomainApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedDomain = (
  args: PatchAppthrustDevV1NamespacedDomainApiArg
): Promise<PatchAppthrustDevV1NamespacedDomainApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedDomainStatus = (
  args: ReadAppthrustDevV1NamespacedDomainStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedDomainStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedDomainStatus = (
  args: ReplaceAppthrustDevV1NamespacedDomainStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedDomainStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1Domain,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedDomainStatus = (
  args: PatchAppthrustDevV1NamespacedDomainStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedDomainStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedEks = (
  args: ListAppthrustDevV1NamespacedEksApiArg
): Promise<ListAppthrustDevV1NamespacedEksApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedEks = (
  args: CreateAppthrustDevV1NamespacedEksApiArg
): Promise<CreateAppthrustDevV1NamespacedEksApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks\`,
    method: 'POST',
    body: args.devAppthrustV1Eks,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedEks = (
  args: DeleteAppthrustDevV1CollectionNamespacedEksApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedEksApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedEks = (
  args: ReadAppthrustDevV1NamespacedEksApiArg
): Promise<ReadAppthrustDevV1NamespacedEksApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedEks = (
  args: ReplaceAppthrustDevV1NamespacedEksApiArg
): Promise<ReplaceAppthrustDevV1NamespacedEksApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1Eks,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedEks = (
  args: DeleteAppthrustDevV1NamespacedEksApiArg
): Promise<DeleteAppthrustDevV1NamespacedEksApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedEks = (
  args: PatchAppthrustDevV1NamespacedEksApiArg
): Promise<PatchAppthrustDevV1NamespacedEksApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedEksStatus = (
  args: ReadAppthrustDevV1NamespacedEksStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedEksStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedEksStatus = (
  args: ReplaceAppthrustDevV1NamespacedEksStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedEksStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1Eks,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedEksStatus = (
  args: PatchAppthrustDevV1NamespacedEksStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedEksStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedHttprouteToIngress = (
  args: ListAppthrustDevV1NamespacedHttprouteToIngressApiArg
): Promise<ListAppthrustDevV1NamespacedHttprouteToIngressApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedHttprouteToIngress = (
  args: CreateAppthrustDevV1NamespacedHttprouteToIngressApiArg
): Promise<CreateAppthrustDevV1NamespacedHttprouteToIngressApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses\`,
    method: 'POST',
    body: args.devAppthrustV1HttprouteToIngress,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedHttprouteToIngress = (
  args: DeleteAppthrustDevV1CollectionNamespacedHttprouteToIngressApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedHttprouteToIngressApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedHttprouteToIngress = (
  args: ReadAppthrustDevV1NamespacedHttprouteToIngressApiArg
): Promise<ReadAppthrustDevV1NamespacedHttprouteToIngressApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedHttprouteToIngress = (
  args: ReplaceAppthrustDevV1NamespacedHttprouteToIngressApiArg
): Promise<ReplaceAppthrustDevV1NamespacedHttprouteToIngressApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1HttprouteToIngress,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedHttprouteToIngress = (
  args: DeleteAppthrustDevV1NamespacedHttprouteToIngressApiArg
): Promise<DeleteAppthrustDevV1NamespacedHttprouteToIngressApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedHttprouteToIngress = (
  args: PatchAppthrustDevV1NamespacedHttprouteToIngressApiArg
): Promise<PatchAppthrustDevV1NamespacedHttprouteToIngressApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedHttprouteToIngressStatus = (
  args: ReadAppthrustDevV1NamespacedHttprouteToIngressStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedHttprouteToIngressStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedHttprouteToIngressStatus = (
  args: ReplaceAppthrustDevV1NamespacedHttprouteToIngressStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedHttprouteToIngressStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1HttprouteToIngress,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedHttprouteToIngressStatus = (
  args: PatchAppthrustDevV1NamespacedHttprouteToIngressStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedHttprouteToIngressStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedIamData = (
  args: ListAppthrustDevV1NamespacedIamDataApiArg
): Promise<ListAppthrustDevV1NamespacedIamDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedIamData = (
  args: CreateAppthrustDevV1NamespacedIamDataApiArg
): Promise<CreateAppthrustDevV1NamespacedIamDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas\`,
    method: 'POST',
    body: args.devAppthrustV1IamData,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedIamData = (
  args: DeleteAppthrustDevV1CollectionNamespacedIamDataApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedIamDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedIamData = (
  args: ReadAppthrustDevV1NamespacedIamDataApiArg
): Promise<ReadAppthrustDevV1NamespacedIamDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedIamData = (
  args: ReplaceAppthrustDevV1NamespacedIamDataApiArg
): Promise<ReplaceAppthrustDevV1NamespacedIamDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1IamData,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedIamData = (
  args: DeleteAppthrustDevV1NamespacedIamDataApiArg
): Promise<DeleteAppthrustDevV1NamespacedIamDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedIamData = (
  args: PatchAppthrustDevV1NamespacedIamDataApiArg
): Promise<PatchAppthrustDevV1NamespacedIamDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedIamDataStatus = (
  args: ReadAppthrustDevV1NamespacedIamDataStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedIamDataStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedIamDataStatus = (
  args: ReplaceAppthrustDevV1NamespacedIamDataStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedIamDataStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1IamData,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedIamDataStatus = (
  args: PatchAppthrustDevV1NamespacedIamDataStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedIamDataStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedIam = (
  args: ListAppthrustDevV1NamespacedIamApiArg
): Promise<ListAppthrustDevV1NamespacedIamApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedIam = (
  args: CreateAppthrustDevV1NamespacedIamApiArg
): Promise<CreateAppthrustDevV1NamespacedIamApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams\`,
    method: 'POST',
    body: args.devAppthrustV1Iam,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedIam = (
  args: DeleteAppthrustDevV1CollectionNamespacedIamApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedIamApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedIam = (
  args: ReadAppthrustDevV1NamespacedIamApiArg
): Promise<ReadAppthrustDevV1NamespacedIamApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedIam = (
  args: ReplaceAppthrustDevV1NamespacedIamApiArg
): Promise<ReplaceAppthrustDevV1NamespacedIamApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1Iam,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedIam = (
  args: DeleteAppthrustDevV1NamespacedIamApiArg
): Promise<DeleteAppthrustDevV1NamespacedIamApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedIam = (
  args: PatchAppthrustDevV1NamespacedIamApiArg
): Promise<PatchAppthrustDevV1NamespacedIamApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedIamStatus = (
  args: ReadAppthrustDevV1NamespacedIamStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedIamStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedIamStatus = (
  args: ReplaceAppthrustDevV1NamespacedIamStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedIamStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1Iam,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedIamStatus = (
  args: PatchAppthrustDevV1NamespacedIamStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedIamStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedKeycloakClientSecret = (
  args: ListAppthrustDevV1NamespacedKeycloakClientSecretApiArg
): Promise<ListAppthrustDevV1NamespacedKeycloakClientSecretApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedKeycloakClientSecret = (
  args: CreateAppthrustDevV1NamespacedKeycloakClientSecretApiArg
): Promise<CreateAppthrustDevV1NamespacedKeycloakClientSecretApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets\`,
    method: 'POST',
    body: args.devAppthrustV1KeycloakClientSecret,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedKeycloakClientSecret = (
  args: DeleteAppthrustDevV1CollectionNamespacedKeycloakClientSecretApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedKeycloakClientSecretApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedKeycloakClientSecret = (
  args: ReadAppthrustDevV1NamespacedKeycloakClientSecretApiArg
): Promise<ReadAppthrustDevV1NamespacedKeycloakClientSecretApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedKeycloakClientSecret = (
  args: ReplaceAppthrustDevV1NamespacedKeycloakClientSecretApiArg
): Promise<ReplaceAppthrustDevV1NamespacedKeycloakClientSecretApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1KeycloakClientSecret,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedKeycloakClientSecret = (
  args: DeleteAppthrustDevV1NamespacedKeycloakClientSecretApiArg
): Promise<DeleteAppthrustDevV1NamespacedKeycloakClientSecretApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedKeycloakClientSecret = (
  args: PatchAppthrustDevV1NamespacedKeycloakClientSecretApiArg
): Promise<PatchAppthrustDevV1NamespacedKeycloakClientSecretApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedKeycloakClientSecretStatus = (
  args: ReadAppthrustDevV1NamespacedKeycloakClientSecretStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedKeycloakClientSecretStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedKeycloakClientSecretStatus = (
  args: ReplaceAppthrustDevV1NamespacedKeycloakClientSecretStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedKeycloakClientSecretStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1KeycloakClientSecret,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedKeycloakClientSecretStatus = (
  args: PatchAppthrustDevV1NamespacedKeycloakClientSecretStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedKeycloakClientSecretStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedKeycloakKeyId = (
  args: ListAppthrustDevV1NamespacedKeycloakKeyIdApiArg
): Promise<ListAppthrustDevV1NamespacedKeycloakKeyIdApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedKeycloakKeyId = (
  args: CreateAppthrustDevV1NamespacedKeycloakKeyIdApiArg
): Promise<CreateAppthrustDevV1NamespacedKeycloakKeyIdApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids\`,
    method: 'POST',
    body: args.devAppthrustV1KeycloakKeyId,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedKeycloakKeyId = (
  args: DeleteAppthrustDevV1CollectionNamespacedKeycloakKeyIdApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedKeycloakKeyIdApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedKeycloakKeyId = (
  args: ReadAppthrustDevV1NamespacedKeycloakKeyIdApiArg
): Promise<ReadAppthrustDevV1NamespacedKeycloakKeyIdApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedKeycloakKeyId = (
  args: ReplaceAppthrustDevV1NamespacedKeycloakKeyIdApiArg
): Promise<ReplaceAppthrustDevV1NamespacedKeycloakKeyIdApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1KeycloakKeyId,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedKeycloakKeyId = (
  args: DeleteAppthrustDevV1NamespacedKeycloakKeyIdApiArg
): Promise<DeleteAppthrustDevV1NamespacedKeycloakKeyIdApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedKeycloakKeyId = (
  args: PatchAppthrustDevV1NamespacedKeycloakKeyIdApiArg
): Promise<PatchAppthrustDevV1NamespacedKeycloakKeyIdApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedKeycloakKeyIdStatus = (
  args: ReadAppthrustDevV1NamespacedKeycloakKeyIdStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedKeycloakKeyIdStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedKeycloakKeyIdStatus = (
  args: ReplaceAppthrustDevV1NamespacedKeycloakKeyIdStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedKeycloakKeyIdStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1KeycloakKeyId,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedKeycloakKeyIdStatus = (
  args: PatchAppthrustDevV1NamespacedKeycloakKeyIdStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedKeycloakKeyIdStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedKeycloakPasswordInit = (
  args: ListAppthrustDevV1NamespacedKeycloakPasswordInitApiArg
): Promise<ListAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedKeycloakPasswordInit = (
  args: CreateAppthrustDevV1NamespacedKeycloakPasswordInitApiArg
): Promise<CreateAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits\`,
    method: 'POST',
    body: args.devAppthrustV1KeycloakPasswordInit,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedKeycloakPasswordInit = (
  args: DeleteAppthrustDevV1CollectionNamespacedKeycloakPasswordInitApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedKeycloakPasswordInitApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedKeycloakPasswordInit = (
  args: ReadAppthrustDevV1NamespacedKeycloakPasswordInitApiArg
): Promise<ReadAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedKeycloakPasswordInit = (
  args: ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitApiArg
): Promise<ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1KeycloakPasswordInit,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedKeycloakPasswordInit = (
  args: DeleteAppthrustDevV1NamespacedKeycloakPasswordInitApiArg
): Promise<DeleteAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedKeycloakPasswordInit = (
  args: PatchAppthrustDevV1NamespacedKeycloakPasswordInitApiArg
): Promise<PatchAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedKeycloakPasswordInitStatus = (
  args: ReadAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedKeycloakPasswordInitStatus = (
  args: ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1KeycloakPasswordInit,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedKeycloakPasswordInitStatus = (
  args: PatchAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedNextAuthSecretRequest = (
  args: ListAppthrustDevV1NamespacedNextAuthSecretRequestApiArg
): Promise<ListAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedNextAuthSecretRequest = (
  args: CreateAppthrustDevV1NamespacedNextAuthSecretRequestApiArg
): Promise<CreateAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests\`,
    method: 'POST',
    body: args.devAppthrustV1NextAuthSecretRequest,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedNextAuthSecretRequest = (
  args: DeleteAppthrustDevV1CollectionNamespacedNextAuthSecretRequestApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedNextAuthSecretRequestApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedNextAuthSecretRequest = (
  args: ReadAppthrustDevV1NamespacedNextAuthSecretRequestApiArg
): Promise<ReadAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedNextAuthSecretRequest = (
  args: ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestApiArg
): Promise<ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1NextAuthSecretRequest,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedNextAuthSecretRequest = (
  args: DeleteAppthrustDevV1NamespacedNextAuthSecretRequestApiArg
): Promise<DeleteAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedNextAuthSecretRequest = (
  args: PatchAppthrustDevV1NamespacedNextAuthSecretRequestApiArg
): Promise<PatchAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedNextAuthSecretRequestStatus = (
  args: ReadAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedNextAuthSecretRequestStatus = (
  args: ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1NextAuthSecretRequest,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedNextAuthSecretRequestStatus = (
  args: PatchAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedProject = (
  args: ListAppthrustDevV1NamespacedProjectApiArg
): Promise<ListAppthrustDevV1NamespacedProjectApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedProject = (
  args: CreateAppthrustDevV1NamespacedProjectApiArg
): Promise<CreateAppthrustDevV1NamespacedProjectApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects\`,
    method: 'POST',
    body: args.devAppthrustV1Project,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedProject = (
  args: DeleteAppthrustDevV1CollectionNamespacedProjectApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedProjectApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedProject = (
  args: ReadAppthrustDevV1NamespacedProjectApiArg
): Promise<ReadAppthrustDevV1NamespacedProjectApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedProject = (
  args: ReplaceAppthrustDevV1NamespacedProjectApiArg
): Promise<ReplaceAppthrustDevV1NamespacedProjectApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1Project,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedProject = (
  args: DeleteAppthrustDevV1NamespacedProjectApiArg
): Promise<DeleteAppthrustDevV1NamespacedProjectApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedProject = (
  args: PatchAppthrustDevV1NamespacedProjectApiArg
): Promise<PatchAppthrustDevV1NamespacedProjectApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedProjectStatus = (
  args: ReadAppthrustDevV1NamespacedProjectStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedProjectStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedProjectStatus = (
  args: ReplaceAppthrustDevV1NamespacedProjectStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedProjectStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1Project,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedProjectStatus = (
  args: PatchAppthrustDevV1NamespacedProjectStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedProjectStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedReleaseChannel = (
  args: ListAppthrustDevV1NamespacedReleaseChannelApiArg
): Promise<ListAppthrustDevV1NamespacedReleaseChannelApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedReleaseChannel = (
  args: CreateAppthrustDevV1NamespacedReleaseChannelApiArg
): Promise<CreateAppthrustDevV1NamespacedReleaseChannelApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels\`,
    method: 'POST',
    body: args.devAppthrustV1ReleaseChannel,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedReleaseChannel = (
  args: DeleteAppthrustDevV1CollectionNamespacedReleaseChannelApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedReleaseChannelApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedReleaseChannel = (
  args: ReadAppthrustDevV1NamespacedReleaseChannelApiArg
): Promise<ReadAppthrustDevV1NamespacedReleaseChannelApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedReleaseChannel = (
  args: ReplaceAppthrustDevV1NamespacedReleaseChannelApiArg
): Promise<ReplaceAppthrustDevV1NamespacedReleaseChannelApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1ReleaseChannel,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedReleaseChannel = (
  args: DeleteAppthrustDevV1NamespacedReleaseChannelApiArg
): Promise<DeleteAppthrustDevV1NamespacedReleaseChannelApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedReleaseChannel = (
  args: PatchAppthrustDevV1NamespacedReleaseChannelApiArg
): Promise<PatchAppthrustDevV1NamespacedReleaseChannelApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedReleaseChannelStatus = (
  args: ReadAppthrustDevV1NamespacedReleaseChannelStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedReleaseChannelStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedReleaseChannelStatus = (
  args: ReplaceAppthrustDevV1NamespacedReleaseChannelStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedReleaseChannelStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1ReleaseChannel,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedReleaseChannelStatus = (
  args: PatchAppthrustDevV1NamespacedReleaseChannelStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedReleaseChannelStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedResourceValueSync = (
  args: ListAppthrustDevV1NamespacedResourceValueSyncApiArg
): Promise<ListAppthrustDevV1NamespacedResourceValueSyncApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedResourceValueSync = (
  args: CreateAppthrustDevV1NamespacedResourceValueSyncApiArg
): Promise<CreateAppthrustDevV1NamespacedResourceValueSyncApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs\`,
    method: 'POST',
    body: args.devAppthrustV1ResourceValueSync,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedResourceValueSync = (
  args: DeleteAppthrustDevV1CollectionNamespacedResourceValueSyncApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedResourceValueSyncApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedResourceValueSync = (
  args: ReadAppthrustDevV1NamespacedResourceValueSyncApiArg
): Promise<ReadAppthrustDevV1NamespacedResourceValueSyncApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedResourceValueSync = (
  args: ReplaceAppthrustDevV1NamespacedResourceValueSyncApiArg
): Promise<ReplaceAppthrustDevV1NamespacedResourceValueSyncApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1ResourceValueSync,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedResourceValueSync = (
  args: DeleteAppthrustDevV1NamespacedResourceValueSyncApiArg
): Promise<DeleteAppthrustDevV1NamespacedResourceValueSyncApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedResourceValueSync = (
  args: PatchAppthrustDevV1NamespacedResourceValueSyncApiArg
): Promise<PatchAppthrustDevV1NamespacedResourceValueSyncApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedResourceValueSyncStatus = (
  args: ReadAppthrustDevV1NamespacedResourceValueSyncStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedResourceValueSyncStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedResourceValueSyncStatus = (
  args: ReplaceAppthrustDevV1NamespacedResourceValueSyncStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedResourceValueSyncStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1ResourceValueSync,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedResourceValueSyncStatus = (
  args: PatchAppthrustDevV1NamespacedResourceValueSyncStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedResourceValueSyncStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedTfApply = (
  args: ListAppthrustDevV1NamespacedTfApplyApiArg
): Promise<ListAppthrustDevV1NamespacedTfApplyApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedTfApply = (
  args: CreateAppthrustDevV1NamespacedTfApplyApiArg
): Promise<CreateAppthrustDevV1NamespacedTfApplyApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies\`,
    method: 'POST',
    body: args.devAppthrustV1TfApply,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedTfApply = (
  args: DeleteAppthrustDevV1CollectionNamespacedTfApplyApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedTfApplyApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedTfApply = (
  args: ReadAppthrustDevV1NamespacedTfApplyApiArg
): Promise<ReadAppthrustDevV1NamespacedTfApplyApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedTfApply = (
  args: ReplaceAppthrustDevV1NamespacedTfApplyApiArg
): Promise<ReplaceAppthrustDevV1NamespacedTfApplyApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1TfApply,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedTfApply = (
  args: DeleteAppthrustDevV1NamespacedTfApplyApiArg
): Promise<DeleteAppthrustDevV1NamespacedTfApplyApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedTfApply = (
  args: PatchAppthrustDevV1NamespacedTfApplyApiArg
): Promise<PatchAppthrustDevV1NamespacedTfApplyApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedTfApplyStatus = (
  args: ReadAppthrustDevV1NamespacedTfApplyStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedTfApplyStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedTfApplyStatus = (
  args: ReplaceAppthrustDevV1NamespacedTfApplyStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedTfApplyStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1TfApply,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedTfApplyStatus = (
  args: PatchAppthrustDevV1NamespacedTfApplyStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedTfApplyStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedTrafficSplitting = (
  args: ListAppthrustDevV1NamespacedTrafficSplittingApiArg
): Promise<ListAppthrustDevV1NamespacedTrafficSplittingApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedTrafficSplitting = (
  args: CreateAppthrustDevV1NamespacedTrafficSplittingApiArg
): Promise<CreateAppthrustDevV1NamespacedTrafficSplittingApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings\`,
    method: 'POST',
    body: args.devAppthrustV1TrafficSplitting,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedTrafficSplitting = (
  args: DeleteAppthrustDevV1CollectionNamespacedTrafficSplittingApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedTrafficSplittingApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedTrafficSplitting = (
  args: ReadAppthrustDevV1NamespacedTrafficSplittingApiArg
): Promise<ReadAppthrustDevV1NamespacedTrafficSplittingApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedTrafficSplitting = (
  args: ReplaceAppthrustDevV1NamespacedTrafficSplittingApiArg
): Promise<ReplaceAppthrustDevV1NamespacedTrafficSplittingApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1TrafficSplitting,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedTrafficSplitting = (
  args: DeleteAppthrustDevV1NamespacedTrafficSplittingApiArg
): Promise<DeleteAppthrustDevV1NamespacedTrafficSplittingApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedTrafficSplitting = (
  args: PatchAppthrustDevV1NamespacedTrafficSplittingApiArg
): Promise<PatchAppthrustDevV1NamespacedTrafficSplittingApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedTrafficSplittingStatus = (
  args: ReadAppthrustDevV1NamespacedTrafficSplittingStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedTrafficSplittingStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedTrafficSplittingStatus = (
  args: ReplaceAppthrustDevV1NamespacedTrafficSplittingStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedTrafficSplittingStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1TrafficSplitting,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedTrafficSplittingStatus = (
  args: PatchAppthrustDevV1NamespacedTrafficSplittingStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedTrafficSplittingStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedVpcData = (
  args: ListAppthrustDevV1NamespacedVpcDataApiArg
): Promise<ListAppthrustDevV1NamespacedVpcDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedVpcData = (
  args: CreateAppthrustDevV1NamespacedVpcDataApiArg
): Promise<CreateAppthrustDevV1NamespacedVpcDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas\`,
    method: 'POST',
    body: args.devAppthrustV1VpcData,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedVpcData = (
  args: DeleteAppthrustDevV1CollectionNamespacedVpcDataApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedVpcDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedVpcData = (
  args: ReadAppthrustDevV1NamespacedVpcDataApiArg
): Promise<ReadAppthrustDevV1NamespacedVpcDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedVpcData = (
  args: ReplaceAppthrustDevV1NamespacedVpcDataApiArg
): Promise<ReplaceAppthrustDevV1NamespacedVpcDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1VpcData,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedVpcData = (
  args: DeleteAppthrustDevV1NamespacedVpcDataApiArg
): Promise<DeleteAppthrustDevV1NamespacedVpcDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedVpcData = (
  args: PatchAppthrustDevV1NamespacedVpcDataApiArg
): Promise<PatchAppthrustDevV1NamespacedVpcDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedVpcDataStatus = (
  args: ReadAppthrustDevV1NamespacedVpcDataStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedVpcDataStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedVpcDataStatus = (
  args: ReplaceAppthrustDevV1NamespacedVpcDataStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedVpcDataStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1VpcData,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedVpcDataStatus = (
  args: PatchAppthrustDevV1NamespacedVpcDataStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedVpcDataStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedVpc = (
  args: ListAppthrustDevV1NamespacedVpcApiArg
): Promise<ListAppthrustDevV1NamespacedVpcApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedVpc = (
  args: CreateAppthrustDevV1NamespacedVpcApiArg
): Promise<CreateAppthrustDevV1NamespacedVpcApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs\`,
    method: 'POST',
    body: args.devAppthrustV1Vpc,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedVpc = (
  args: DeleteAppthrustDevV1CollectionNamespacedVpcApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedVpcApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedVpc = (
  args: ReadAppthrustDevV1NamespacedVpcApiArg
): Promise<ReadAppthrustDevV1NamespacedVpcApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedVpc = (
  args: ReplaceAppthrustDevV1NamespacedVpcApiArg
): Promise<ReplaceAppthrustDevV1NamespacedVpcApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1Vpc,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedVpc = (
  args: DeleteAppthrustDevV1NamespacedVpcApiArg
): Promise<DeleteAppthrustDevV1NamespacedVpcApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedVpc = (
  args: PatchAppthrustDevV1NamespacedVpcApiArg
): Promise<PatchAppthrustDevV1NamespacedVpcApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedVpcStatus = (
  args: ReadAppthrustDevV1NamespacedVpcStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedVpcStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedVpcStatus = (
  args: ReplaceAppthrustDevV1NamespacedVpcStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedVpcStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1Vpc,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedVpcStatus = (
  args: PatchAppthrustDevV1NamespacedVpcStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedVpcStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWaf = (
  args: ListAppthrustDevV1NamespacedWafApiArg
): Promise<ListAppthrustDevV1NamespacedWafApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWaf = (
  args: CreateAppthrustDevV1NamespacedWafApiArg
): Promise<CreateAppthrustDevV1NamespacedWafApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs\`,
    method: 'POST',
    body: args.devAppthrustV1Waf,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWaf = (
  args: DeleteAppthrustDevV1CollectionNamespacedWafApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWafApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWaf = (
  args: ReadAppthrustDevV1NamespacedWafApiArg
): Promise<ReadAppthrustDevV1NamespacedWafApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWaf = (
  args: ReplaceAppthrustDevV1NamespacedWafApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWafApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1Waf,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWaf = (
  args: DeleteAppthrustDevV1NamespacedWafApiArg
): Promise<DeleteAppthrustDevV1NamespacedWafApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWaf = (
  args: PatchAppthrustDevV1NamespacedWafApiArg
): Promise<PatchAppthrustDevV1NamespacedWafApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWafStatus = (
  args: ReadAppthrustDevV1NamespacedWafStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWafStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWafStatus = (
  args: ReplaceAppthrustDevV1NamespacedWafStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWafStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1Waf,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWafStatus = (
  args: PatchAppthrustDevV1NamespacedWafStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWafStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponentBuildFinished = (
  args: ListAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponentBuildFinished = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponentBuildFinished,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildFinished = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildFinishedApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildFinishedApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentBuildFinished = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentBuildFinished = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentBuildFinished,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponentBuildFinished = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentBuildFinished = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentBuildFinished,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponentBuild = (
  args: ListAppthrustDevV1NamespacedWebAppComponentBuildApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentBuildApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponentBuild = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentBuildApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentBuildApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponentBuild,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponentBuild = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentBuild = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentBuildApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentBuildApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentBuild = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentBuildApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentBuildApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentBuild,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponentBuild = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentBuildApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentBuildApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentBuild = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentBuildApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentBuildApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentBuildStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentBuildStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentBuildStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentBuildStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentBuildStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentBuildStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentBuild,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentBuildStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentBuildStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentBuildStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponentDeployment = (
  args: ListAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponentDeployment = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponentDeployment,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponentDeployment = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentDeploymentApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentDeploymentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentDeployment = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentDeployment = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentDeployment,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponentDeployment = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentDeployment = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentDeploymentStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentDeploymentStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentDeployment,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentDeploymentStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponentGatewayConnection = (
  args: ListAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponentGatewayConnection = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponentGatewayConnection,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponentGatewayConnection = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentGatewayConnectionApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentGatewayConnectionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentGatewayConnection = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentGatewayConnection = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentGatewayConnection,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponentGatewayConnection = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentGatewayConnection = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentGatewayConnection,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponentPipeline = (
  args: ListAppthrustDevV1NamespacedWebAppComponentPipelineApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponentPipeline = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentPipelineApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponentPipeline,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponentPipeline = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentPipelineApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentPipelineApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentPipeline = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentPipelineApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentPipeline = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentPipeline,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponentPipeline = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentPipelineApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentPipeline = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentPipelineApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentPipelineStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentPipelineStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentPipeline,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentPipelineStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfig = (
  args: ListAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfig = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponentReleaseChannelBuildConfig,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponentReleaseChannelBuildConfig = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentReleaseChannelBuildConfigApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentReleaseChannelBuildConfigApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfig = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfig = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentReleaseChannelBuildConfig,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfig = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfig = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentReleaseChannelBuildConfig,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponentRevision = (
  args: ListAppthrustDevV1NamespacedWebAppComponentRevisionApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponentRevision = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentRevisionApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponentRevision,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponentRevision = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentRevisionApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentRevisionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentRevision = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentRevisionApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentRevision = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentRevision,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponentRevision = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentRevisionApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentRevision = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentRevisionApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentRevisionStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentRevisionStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentRevision,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentRevisionStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponent = (
  args: ListAppthrustDevV1NamespacedWebAppComponentApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponent = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponent,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponent = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponent = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponent = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponent,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponent = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponent = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponent,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NextAuthSecretRequestForAllNamespaces = (
  args: ListAppthrustDevV1NextAuthSecretRequestForAllNamespacesApiArg
): Promise<ListAppthrustDevV1NextAuthSecretRequestForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/nextauthsecretrequests\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1ProjectForAllNamespaces = (
  args: ListAppthrustDevV1ProjectForAllNamespacesApiArg
): Promise<ListAppthrustDevV1ProjectForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/projects\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1ReleaseChannelForAllNamespaces = (
  args: ListAppthrustDevV1ReleaseChannelForAllNamespacesApiArg
): Promise<ListAppthrustDevV1ReleaseChannelForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/releasechannels\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1ResourceValueSyncForAllNamespaces = (
  args: ListAppthrustDevV1ResourceValueSyncForAllNamespacesApiArg
): Promise<ListAppthrustDevV1ResourceValueSyncForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/resourcevaluesyncs\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1TfApplyForAllNamespaces = (
  args: ListAppthrustDevV1TfApplyForAllNamespacesApiArg
): Promise<ListAppthrustDevV1TfApplyForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/tfapplies\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1TrafficSplittingForAllNamespaces = (
  args: ListAppthrustDevV1TrafficSplittingForAllNamespacesApiArg
): Promise<ListAppthrustDevV1TrafficSplittingForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/trafficsplittings\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1VpcDataForAllNamespaces = (
  args: ListAppthrustDevV1VpcDataForAllNamespacesApiArg
): Promise<ListAppthrustDevV1VpcDataForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/vpcdatas\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1VpcForAllNamespaces = (
  args: ListAppthrustDevV1VpcForAllNamespacesApiArg
): Promise<ListAppthrustDevV1VpcForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/vpcs\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WafForAllNamespaces = (
  args: ListAppthrustDevV1WafForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WafForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/wafs\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentBuildFinishedForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentBuildFinishedForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentBuildFinishedForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponentbuildfinisheds\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentBuildForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentBuildForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentBuildForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponentbuilds\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentDeploymentForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentDeploymentForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentDeploymentForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponentdeployments\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentGatewayConnectionForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentGatewayConnectionForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentGatewayConnectionForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponentgatewayconnections\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentPipelineForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentPipelineForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentPipelineForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponentpipelines\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentReleaseChannelBuildConfigForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentReleaseChannelBuildConfigForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentReleaseChannelBuildConfigForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponentreleasechannelbuildconfigs\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentRevisionForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentRevisionForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentRevisionForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponentrevisions\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponents\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export type ListAppthrustDevV1AlbGatewayParametersForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1AlbGatewayParametersList;
export type ListAppthrustDevV1AlbGatewayParametersForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1AwsRoute53ZoneForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1AwsRoute53ZoneList;
export type ListAppthrustDevV1AwsRoute53ZoneForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1CertForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1CertList;
export type ListAppthrustDevV1CertForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1ContainerImageTagForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1ContainerImageTagList;
export type ListAppthrustDevV1ContainerImageTagForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1ContainerRepositoryForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1ContainerRepositoryList;
export type ListAppthrustDevV1ContainerRepositoryForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1DnsZoneForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1DnsZoneList;
export type ListAppthrustDevV1DnsZoneForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1DnsZoneTransferForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1DnsZoneTransferList;
export type ListAppthrustDevV1DnsZoneTransferForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1DomainForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1DomainList;
export type ListAppthrustDevV1DomainForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1EksForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1EksList;
export type ListAppthrustDevV1EksForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1HttprouteToIngressForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1HttprouteToIngressList;
export type ListAppthrustDevV1HttprouteToIngressForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1IamDataForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1IamDataList;
export type ListAppthrustDevV1IamDataForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1IamForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1IamList;
export type ListAppthrustDevV1IamForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1KeycloakClientSecretForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1KeycloakClientSecretList;
export type ListAppthrustDevV1KeycloakClientSecretForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1KeycloakKeyIdForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1KeycloakKeyIdList;
export type ListAppthrustDevV1KeycloakKeyIdForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1KeycloakPasswordInitForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1KeycloakPasswordInitList;
export type ListAppthrustDevV1KeycloakPasswordInitForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1NamespacedAlbGatewayParametersApiResponse =
  /** status 200 OK */ DevAppthrustV1AlbGatewayParametersList;
export type ListAppthrustDevV1NamespacedAlbGatewayParametersApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedAlbGatewayParametersApiResponse = /** status 200 OK */
  | AlbGatewayParameters
  | /** status 201 Created */ AlbGatewayParameters
  | /** status 202 Accepted */ AlbGatewayParameters;
export type CreateAppthrustDevV1NamespacedAlbGatewayParametersApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1AlbGatewayParameters: AlbGatewayParameters;
};
export type DeleteAppthrustDevV1CollectionNamespacedAlbGatewayParametersApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedAlbGatewayParametersApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedAlbGatewayParametersApiResponse = /** status 200 OK */ AlbGatewayParameters;
export type ReadAppthrustDevV1NamespacedAlbGatewayParametersApiArg = {
  /** name of the AlbGatewayParameters */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedAlbGatewayParametersApiResponse = /** status 200 OK */
  | AlbGatewayParameters
  | /** status 201 Created */ AlbGatewayParameters;
export type ReplaceAppthrustDevV1NamespacedAlbGatewayParametersApiArg = {
  /** name of the AlbGatewayParameters */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1AlbGatewayParameters: AlbGatewayParameters;
};
export type DeleteAppthrustDevV1NamespacedAlbGatewayParametersApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedAlbGatewayParametersApiArg = {
  /** name of the AlbGatewayParameters */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedAlbGatewayParametersApiResponse = /** status 200 OK */ AlbGatewayParameters;
export type PatchAppthrustDevV1NamespacedAlbGatewayParametersApiArg = {
  /** name of the AlbGatewayParameters */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedAlbGatewayParametersStatusApiResponse =
  /** status 200 OK */ AlbGatewayParameters;
export type ReadAppthrustDevV1NamespacedAlbGatewayParametersStatusApiArg = {
  /** name of the AlbGatewayParameters */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedAlbGatewayParametersStatusApiResponse = /** status 200 OK */
  | AlbGatewayParameters
  | /** status 201 Created */ AlbGatewayParameters;
export type ReplaceAppthrustDevV1NamespacedAlbGatewayParametersStatusApiArg = {
  /** name of the AlbGatewayParameters */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1AlbGatewayParameters: AlbGatewayParameters;
};
export type PatchAppthrustDevV1NamespacedAlbGatewayParametersStatusApiResponse =
  /** status 200 OK */ AlbGatewayParameters;
export type PatchAppthrustDevV1NamespacedAlbGatewayParametersStatusApiArg = {
  /** name of the AlbGatewayParameters */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse =
  /** status 200 OK */ DevAppthrustV1AwsRoute53ZoneList;
export type ListAppthrustDevV1NamespacedAwsRoute53ZoneApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse = /** status 200 OK */
  | AwsRoute53Zone
  | /** status 201 Created */ AwsRoute53Zone
  | /** status 202 Accepted */ AwsRoute53Zone;
export type CreateAppthrustDevV1NamespacedAwsRoute53ZoneApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1AwsRoute53Zone: AwsRoute53Zone;
};
export type DeleteAppthrustDevV1CollectionNamespacedAwsRoute53ZoneApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedAwsRoute53ZoneApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse = /** status 200 OK */ AwsRoute53Zone;
export type ReadAppthrustDevV1NamespacedAwsRoute53ZoneApiArg = {
  /** name of the AwsRoute53Zone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse = /** status 200 OK */
  | AwsRoute53Zone
  | /** status 201 Created */ AwsRoute53Zone;
export type ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneApiArg = {
  /** name of the AwsRoute53Zone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1AwsRoute53Zone: AwsRoute53Zone;
};
export type DeleteAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedAwsRoute53ZoneApiArg = {
  /** name of the AwsRoute53Zone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse = /** status 200 OK */ AwsRoute53Zone;
export type PatchAppthrustDevV1NamespacedAwsRoute53ZoneApiArg = {
  /** name of the AwsRoute53Zone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiResponse = /** status 200 OK */ AwsRoute53Zone;
export type ReadAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiArg = {
  /** name of the AwsRoute53Zone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiResponse = /** status 200 OK */
  | AwsRoute53Zone
  | /** status 201 Created */ AwsRoute53Zone;
export type ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiArg = {
  /** name of the AwsRoute53Zone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1AwsRoute53Zone: AwsRoute53Zone;
};
export type PatchAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiResponse = /** status 200 OK */ AwsRoute53Zone;
export type PatchAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiArg = {
  /** name of the AwsRoute53Zone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedCertApiResponse = /** status 200 OK */ DevAppthrustV1CertList;
export type ListAppthrustDevV1NamespacedCertApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedCertApiResponse = /** status 200 OK */
  | Cert
  | /** status 201 Created */ Cert
  | /** status 202 Accepted */ Cert;
export type CreateAppthrustDevV1NamespacedCertApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Cert: Cert;
};
export type DeleteAppthrustDevV1CollectionNamespacedCertApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedCertApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedCertApiResponse = /** status 200 OK */ Cert;
export type ReadAppthrustDevV1NamespacedCertApiArg = {
  /** name of the Cert */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedCertApiResponse = /** status 200 OK */ Cert | /** status 201 Created */ Cert;
export type ReplaceAppthrustDevV1NamespacedCertApiArg = {
  /** name of the Cert */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Cert: Cert;
};
export type DeleteAppthrustDevV1NamespacedCertApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedCertApiArg = {
  /** name of the Cert */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedCertApiResponse = /** status 200 OK */ Cert;
export type PatchAppthrustDevV1NamespacedCertApiArg = {
  /** name of the Cert */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedCertStatusApiResponse = /** status 200 OK */ Cert;
export type ReadAppthrustDevV1NamespacedCertStatusApiArg = {
  /** name of the Cert */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedCertStatusApiResponse = /** status 200 OK */
  | Cert
  | /** status 201 Created */ Cert;
export type ReplaceAppthrustDevV1NamespacedCertStatusApiArg = {
  /** name of the Cert */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Cert: Cert;
};
export type PatchAppthrustDevV1NamespacedCertStatusApiResponse = /** status 200 OK */ Cert;
export type PatchAppthrustDevV1NamespacedCertStatusApiArg = {
  /** name of the Cert */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedContainerImageTagApiResponse =
  /** status 200 OK */ DevAppthrustV1ContainerImageTagList;
export type ListAppthrustDevV1NamespacedContainerImageTagApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedContainerImageTagApiResponse = /** status 200 OK */
  | ContainerImageTag
  | /** status 201 Created */ ContainerImageTag
  | /** status 202 Accepted */ ContainerImageTag;
export type CreateAppthrustDevV1NamespacedContainerImageTagApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ContainerImageTag: ContainerImageTag;
};
export type DeleteAppthrustDevV1CollectionNamespacedContainerImageTagApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedContainerImageTagApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedContainerImageTagApiResponse = /** status 200 OK */ ContainerImageTag;
export type ReadAppthrustDevV1NamespacedContainerImageTagApiArg = {
  /** name of the ContainerImageTag */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedContainerImageTagApiResponse = /** status 200 OK */
  | ContainerImageTag
  | /** status 201 Created */ ContainerImageTag;
export type ReplaceAppthrustDevV1NamespacedContainerImageTagApiArg = {
  /** name of the ContainerImageTag */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ContainerImageTag: ContainerImageTag;
};
export type DeleteAppthrustDevV1NamespacedContainerImageTagApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedContainerImageTagApiArg = {
  /** name of the ContainerImageTag */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedContainerImageTagApiResponse = /** status 200 OK */ ContainerImageTag;
export type PatchAppthrustDevV1NamespacedContainerImageTagApiArg = {
  /** name of the ContainerImageTag */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedContainerImageTagStatusApiResponse = /** status 200 OK */ ContainerImageTag;
export type ReadAppthrustDevV1NamespacedContainerImageTagStatusApiArg = {
  /** name of the ContainerImageTag */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedContainerImageTagStatusApiResponse = /** status 200 OK */
  | ContainerImageTag
  | /** status 201 Created */ ContainerImageTag;
export type ReplaceAppthrustDevV1NamespacedContainerImageTagStatusApiArg = {
  /** name of the ContainerImageTag */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ContainerImageTag: ContainerImageTag;
};
export type PatchAppthrustDevV1NamespacedContainerImageTagStatusApiResponse = /** status 200 OK */ ContainerImageTag;
export type PatchAppthrustDevV1NamespacedContainerImageTagStatusApiArg = {
  /** name of the ContainerImageTag */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedContainerRepositoryApiResponse =
  /** status 200 OK */ DevAppthrustV1ContainerRepositoryList;
export type ListAppthrustDevV1NamespacedContainerRepositoryApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedContainerRepositoryApiResponse = /** status 200 OK */
  | ContainerRepository
  | /** status 201 Created */ ContainerRepository
  | /** status 202 Accepted */ ContainerRepository;
export type CreateAppthrustDevV1NamespacedContainerRepositoryApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ContainerRepository: ContainerRepository;
};
export type DeleteAppthrustDevV1CollectionNamespacedContainerRepositoryApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedContainerRepositoryApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedContainerRepositoryApiResponse = /** status 200 OK */ ContainerRepository;
export type ReadAppthrustDevV1NamespacedContainerRepositoryApiArg = {
  /** name of the ContainerRepository */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedContainerRepositoryApiResponse = /** status 200 OK */
  | ContainerRepository
  | /** status 201 Created */ ContainerRepository;
export type ReplaceAppthrustDevV1NamespacedContainerRepositoryApiArg = {
  /** name of the ContainerRepository */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ContainerRepository: ContainerRepository;
};
export type DeleteAppthrustDevV1NamespacedContainerRepositoryApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedContainerRepositoryApiArg = {
  /** name of the ContainerRepository */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedContainerRepositoryApiResponse = /** status 200 OK */ ContainerRepository;
export type PatchAppthrustDevV1NamespacedContainerRepositoryApiArg = {
  /** name of the ContainerRepository */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedContainerRepositoryStatusApiResponse = /** status 200 OK */ ContainerRepository;
export type ReadAppthrustDevV1NamespacedContainerRepositoryStatusApiArg = {
  /** name of the ContainerRepository */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedContainerRepositoryStatusApiResponse = /** status 200 OK */
  | ContainerRepository
  | /** status 201 Created */ ContainerRepository;
export type ReplaceAppthrustDevV1NamespacedContainerRepositoryStatusApiArg = {
  /** name of the ContainerRepository */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ContainerRepository: ContainerRepository;
};
export type PatchAppthrustDevV1NamespacedContainerRepositoryStatusApiResponse =
  /** status 200 OK */ ContainerRepository;
export type PatchAppthrustDevV1NamespacedContainerRepositoryStatusApiArg = {
  /** name of the ContainerRepository */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedDnsZoneApiResponse = /** status 200 OK */ DevAppthrustV1DnsZoneList;
export type ListAppthrustDevV1NamespacedDnsZoneApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedDnsZoneApiResponse = /** status 200 OK */
  | DnsZone
  | /** status 201 Created */ DnsZone
  | /** status 202 Accepted */ DnsZone;
export type CreateAppthrustDevV1NamespacedDnsZoneApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1DnsZone: DnsZone;
};
export type DeleteAppthrustDevV1CollectionNamespacedDnsZoneApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedDnsZoneApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedDnsZoneApiResponse = /** status 200 OK */ DnsZone;
export type ReadAppthrustDevV1NamespacedDnsZoneApiArg = {
  /** name of the DnsZone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedDnsZoneApiResponse = /** status 200 OK */
  | DnsZone
  | /** status 201 Created */ DnsZone;
export type ReplaceAppthrustDevV1NamespacedDnsZoneApiArg = {
  /** name of the DnsZone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1DnsZone: DnsZone;
};
export type DeleteAppthrustDevV1NamespacedDnsZoneApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedDnsZoneApiArg = {
  /** name of the DnsZone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedDnsZoneApiResponse = /** status 200 OK */ DnsZone;
export type PatchAppthrustDevV1NamespacedDnsZoneApiArg = {
  /** name of the DnsZone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedDnsZoneStatusApiResponse = /** status 200 OK */ DnsZone;
export type ReadAppthrustDevV1NamespacedDnsZoneStatusApiArg = {
  /** name of the DnsZone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedDnsZoneStatusApiResponse = /** status 200 OK */
  | DnsZone
  | /** status 201 Created */ DnsZone;
export type ReplaceAppthrustDevV1NamespacedDnsZoneStatusApiArg = {
  /** name of the DnsZone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1DnsZone: DnsZone;
};
export type PatchAppthrustDevV1NamespacedDnsZoneStatusApiResponse = /** status 200 OK */ DnsZone;
export type PatchAppthrustDevV1NamespacedDnsZoneStatusApiArg = {
  /** name of the DnsZone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedDnsZoneTransferApiResponse =
  /** status 200 OK */ DevAppthrustV1DnsZoneTransferList;
export type ListAppthrustDevV1NamespacedDnsZoneTransferApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedDnsZoneTransferApiResponse = /** status 200 OK */
  | DnsZoneTransfer
  | /** status 201 Created */ DnsZoneTransfer
  | /** status 202 Accepted */ DnsZoneTransfer;
export type CreateAppthrustDevV1NamespacedDnsZoneTransferApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1DnsZoneTransfer: DnsZoneTransfer;
};
export type DeleteAppthrustDevV1CollectionNamespacedDnsZoneTransferApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedDnsZoneTransferApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedDnsZoneTransferApiResponse = /** status 200 OK */ DnsZoneTransfer;
export type ReadAppthrustDevV1NamespacedDnsZoneTransferApiArg = {
  /** name of the DnsZoneTransfer */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedDnsZoneTransferApiResponse = /** status 200 OK */
  | DnsZoneTransfer
  | /** status 201 Created */ DnsZoneTransfer;
export type ReplaceAppthrustDevV1NamespacedDnsZoneTransferApiArg = {
  /** name of the DnsZoneTransfer */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1DnsZoneTransfer: DnsZoneTransfer;
};
export type DeleteAppthrustDevV1NamespacedDnsZoneTransferApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedDnsZoneTransferApiArg = {
  /** name of the DnsZoneTransfer */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedDnsZoneTransferApiResponse = /** status 200 OK */ DnsZoneTransfer;
export type PatchAppthrustDevV1NamespacedDnsZoneTransferApiArg = {
  /** name of the DnsZoneTransfer */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedDnsZoneTransferStatusApiResponse = /** status 200 OK */ DnsZoneTransfer;
export type ReadAppthrustDevV1NamespacedDnsZoneTransferStatusApiArg = {
  /** name of the DnsZoneTransfer */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedDnsZoneTransferStatusApiResponse = /** status 200 OK */
  | DnsZoneTransfer
  | /** status 201 Created */ DnsZoneTransfer;
export type ReplaceAppthrustDevV1NamespacedDnsZoneTransferStatusApiArg = {
  /** name of the DnsZoneTransfer */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1DnsZoneTransfer: DnsZoneTransfer;
};
export type PatchAppthrustDevV1NamespacedDnsZoneTransferStatusApiResponse = /** status 200 OK */ DnsZoneTransfer;
export type PatchAppthrustDevV1NamespacedDnsZoneTransferStatusApiArg = {
  /** name of the DnsZoneTransfer */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedDomainApiResponse = /** status 200 OK */ DevAppthrustV1DomainList;
export type ListAppthrustDevV1NamespacedDomainApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedDomainApiResponse = /** status 200 OK */
  | Domain
  | /** status 201 Created */ Domain
  | /** status 202 Accepted */ Domain;
export type CreateAppthrustDevV1NamespacedDomainApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Domain: Domain;
};
export type DeleteAppthrustDevV1CollectionNamespacedDomainApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedDomainApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedDomainApiResponse = /** status 200 OK */ Domain;
export type ReadAppthrustDevV1NamespacedDomainApiArg = {
  /** name of the Domain */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedDomainApiResponse = /** status 200 OK */
  | Domain
  | /** status 201 Created */ Domain;
export type ReplaceAppthrustDevV1NamespacedDomainApiArg = {
  /** name of the Domain */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Domain: Domain;
};
export type DeleteAppthrustDevV1NamespacedDomainApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedDomainApiArg = {
  /** name of the Domain */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedDomainApiResponse = /** status 200 OK */ Domain;
export type PatchAppthrustDevV1NamespacedDomainApiArg = {
  /** name of the Domain */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedDomainStatusApiResponse = /** status 200 OK */ Domain;
export type ReadAppthrustDevV1NamespacedDomainStatusApiArg = {
  /** name of the Domain */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedDomainStatusApiResponse = /** status 200 OK */
  | Domain
  | /** status 201 Created */ Domain;
export type ReplaceAppthrustDevV1NamespacedDomainStatusApiArg = {
  /** name of the Domain */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Domain: Domain;
};
export type PatchAppthrustDevV1NamespacedDomainStatusApiResponse = /** status 200 OK */ Domain;
export type PatchAppthrustDevV1NamespacedDomainStatusApiArg = {
  /** name of the Domain */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedEksApiResponse = /** status 200 OK */ DevAppthrustV1EksList;
export type ListAppthrustDevV1NamespacedEksApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedEksApiResponse = /** status 200 OK */
  | Eks
  | /** status 201 Created */ Eks
  | /** status 202 Accepted */ Eks;
export type CreateAppthrustDevV1NamespacedEksApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Eks: Eks;
};
export type DeleteAppthrustDevV1CollectionNamespacedEksApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedEksApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedEksApiResponse = /** status 200 OK */ Eks;
export type ReadAppthrustDevV1NamespacedEksApiArg = {
  /** name of the Eks */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedEksApiResponse = /** status 200 OK */ Eks | /** status 201 Created */ Eks;
export type ReplaceAppthrustDevV1NamespacedEksApiArg = {
  /** name of the Eks */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Eks: Eks;
};
export type DeleteAppthrustDevV1NamespacedEksApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedEksApiArg = {
  /** name of the Eks */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedEksApiResponse = /** status 200 OK */ Eks;
export type PatchAppthrustDevV1NamespacedEksApiArg = {
  /** name of the Eks */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedEksStatusApiResponse = /** status 200 OK */ Eks;
export type ReadAppthrustDevV1NamespacedEksStatusApiArg = {
  /** name of the Eks */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedEksStatusApiResponse = /** status 200 OK */
  | Eks
  | /** status 201 Created */ Eks;
export type ReplaceAppthrustDevV1NamespacedEksStatusApiArg = {
  /** name of the Eks */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Eks: Eks;
};
export type PatchAppthrustDevV1NamespacedEksStatusApiResponse = /** status 200 OK */ Eks;
export type PatchAppthrustDevV1NamespacedEksStatusApiArg = {
  /** name of the Eks */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedHttprouteToIngressApiResponse =
  /** status 200 OK */ DevAppthrustV1HttprouteToIngressList;
export type ListAppthrustDevV1NamespacedHttprouteToIngressApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedHttprouteToIngressApiResponse = /** status 200 OK */
  | HttprouteToIngress
  | /** status 201 Created */ HttprouteToIngress
  | /** status 202 Accepted */ HttprouteToIngress;
export type CreateAppthrustDevV1NamespacedHttprouteToIngressApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1HttprouteToIngress: HttprouteToIngress;
};
export type DeleteAppthrustDevV1CollectionNamespacedHttprouteToIngressApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedHttprouteToIngressApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedHttprouteToIngressApiResponse = /** status 200 OK */ HttprouteToIngress;
export type ReadAppthrustDevV1NamespacedHttprouteToIngressApiArg = {
  /** name of the HttprouteToIngress */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedHttprouteToIngressApiResponse = /** status 200 OK */
  | HttprouteToIngress
  | /** status 201 Created */ HttprouteToIngress;
export type ReplaceAppthrustDevV1NamespacedHttprouteToIngressApiArg = {
  /** name of the HttprouteToIngress */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1HttprouteToIngress: HttprouteToIngress;
};
export type DeleteAppthrustDevV1NamespacedHttprouteToIngressApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedHttprouteToIngressApiArg = {
  /** name of the HttprouteToIngress */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedHttprouteToIngressApiResponse = /** status 200 OK */ HttprouteToIngress;
export type PatchAppthrustDevV1NamespacedHttprouteToIngressApiArg = {
  /** name of the HttprouteToIngress */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedHttprouteToIngressStatusApiResponse = /** status 200 OK */ HttprouteToIngress;
export type ReadAppthrustDevV1NamespacedHttprouteToIngressStatusApiArg = {
  /** name of the HttprouteToIngress */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedHttprouteToIngressStatusApiResponse = /** status 200 OK */
  | HttprouteToIngress
  | /** status 201 Created */ HttprouteToIngress;
export type ReplaceAppthrustDevV1NamespacedHttprouteToIngressStatusApiArg = {
  /** name of the HttprouteToIngress */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1HttprouteToIngress: HttprouteToIngress;
};
export type PatchAppthrustDevV1NamespacedHttprouteToIngressStatusApiResponse = /** status 200 OK */ HttprouteToIngress;
export type PatchAppthrustDevV1NamespacedHttprouteToIngressStatusApiArg = {
  /** name of the HttprouteToIngress */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedIamDataApiResponse = /** status 200 OK */ DevAppthrustV1IamDataList;
export type ListAppthrustDevV1NamespacedIamDataApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedIamDataApiResponse = /** status 200 OK */
  | IamData
  | /** status 201 Created */ IamData
  | /** status 202 Accepted */ IamData;
export type CreateAppthrustDevV1NamespacedIamDataApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1IamData: IamData;
};
export type DeleteAppthrustDevV1CollectionNamespacedIamDataApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedIamDataApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedIamDataApiResponse = /** status 200 OK */ IamData;
export type ReadAppthrustDevV1NamespacedIamDataApiArg = {
  /** name of the IamData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedIamDataApiResponse = /** status 200 OK */
  | IamData
  | /** status 201 Created */ IamData;
export type ReplaceAppthrustDevV1NamespacedIamDataApiArg = {
  /** name of the IamData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1IamData: IamData;
};
export type DeleteAppthrustDevV1NamespacedIamDataApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedIamDataApiArg = {
  /** name of the IamData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedIamDataApiResponse = /** status 200 OK */ IamData;
export type PatchAppthrustDevV1NamespacedIamDataApiArg = {
  /** name of the IamData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedIamDataStatusApiResponse = /** status 200 OK */ IamData;
export type ReadAppthrustDevV1NamespacedIamDataStatusApiArg = {
  /** name of the IamData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedIamDataStatusApiResponse = /** status 200 OK */
  | IamData
  | /** status 201 Created */ IamData;
export type ReplaceAppthrustDevV1NamespacedIamDataStatusApiArg = {
  /** name of the IamData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1IamData: IamData;
};
export type PatchAppthrustDevV1NamespacedIamDataStatusApiResponse = /** status 200 OK */ IamData;
export type PatchAppthrustDevV1NamespacedIamDataStatusApiArg = {
  /** name of the IamData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedIamApiResponse = /** status 200 OK */ DevAppthrustV1IamList;
export type ListAppthrustDevV1NamespacedIamApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedIamApiResponse = /** status 200 OK */
  | Iam
  | /** status 201 Created */ Iam
  | /** status 202 Accepted */ Iam;
export type CreateAppthrustDevV1NamespacedIamApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Iam: Iam;
};
export type DeleteAppthrustDevV1CollectionNamespacedIamApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedIamApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedIamApiResponse = /** status 200 OK */ Iam;
export type ReadAppthrustDevV1NamespacedIamApiArg = {
  /** name of the Iam */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedIamApiResponse = /** status 200 OK */ Iam | /** status 201 Created */ Iam;
export type ReplaceAppthrustDevV1NamespacedIamApiArg = {
  /** name of the Iam */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Iam: Iam;
};
export type DeleteAppthrustDevV1NamespacedIamApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedIamApiArg = {
  /** name of the Iam */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedIamApiResponse = /** status 200 OK */ Iam;
export type PatchAppthrustDevV1NamespacedIamApiArg = {
  /** name of the Iam */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedIamStatusApiResponse = /** status 200 OK */ Iam;
export type ReadAppthrustDevV1NamespacedIamStatusApiArg = {
  /** name of the Iam */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedIamStatusApiResponse = /** status 200 OK */
  | Iam
  | /** status 201 Created */ Iam;
export type ReplaceAppthrustDevV1NamespacedIamStatusApiArg = {
  /** name of the Iam */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Iam: Iam;
};
export type PatchAppthrustDevV1NamespacedIamStatusApiResponse = /** status 200 OK */ Iam;
export type PatchAppthrustDevV1NamespacedIamStatusApiArg = {
  /** name of the Iam */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedKeycloakClientSecretApiResponse =
  /** status 200 OK */ DevAppthrustV1KeycloakClientSecretList;
export type ListAppthrustDevV1NamespacedKeycloakClientSecretApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedKeycloakClientSecretApiResponse = /** status 200 OK */
  | KeycloakClientSecret
  | /** status 201 Created */ KeycloakClientSecret
  | /** status 202 Accepted */ KeycloakClientSecret;
export type CreateAppthrustDevV1NamespacedKeycloakClientSecretApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakClientSecret: KeycloakClientSecret;
};
export type DeleteAppthrustDevV1CollectionNamespacedKeycloakClientSecretApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedKeycloakClientSecretApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedKeycloakClientSecretApiResponse = /** status 200 OK */ KeycloakClientSecret;
export type ReadAppthrustDevV1NamespacedKeycloakClientSecretApiArg = {
  /** name of the KeycloakClientSecret */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedKeycloakClientSecretApiResponse = /** status 200 OK */
  | KeycloakClientSecret
  | /** status 201 Created */ KeycloakClientSecret;
export type ReplaceAppthrustDevV1NamespacedKeycloakClientSecretApiArg = {
  /** name of the KeycloakClientSecret */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakClientSecret: KeycloakClientSecret;
};
export type DeleteAppthrustDevV1NamespacedKeycloakClientSecretApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedKeycloakClientSecretApiArg = {
  /** name of the KeycloakClientSecret */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedKeycloakClientSecretApiResponse = /** status 200 OK */ KeycloakClientSecret;
export type PatchAppthrustDevV1NamespacedKeycloakClientSecretApiArg = {
  /** name of the KeycloakClientSecret */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedKeycloakClientSecretStatusApiResponse =
  /** status 200 OK */ KeycloakClientSecret;
export type ReadAppthrustDevV1NamespacedKeycloakClientSecretStatusApiArg = {
  /** name of the KeycloakClientSecret */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedKeycloakClientSecretStatusApiResponse = /** status 200 OK */
  | KeycloakClientSecret
  | /** status 201 Created */ KeycloakClientSecret;
export type ReplaceAppthrustDevV1NamespacedKeycloakClientSecretStatusApiArg = {
  /** name of the KeycloakClientSecret */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakClientSecret: KeycloakClientSecret;
};
export type PatchAppthrustDevV1NamespacedKeycloakClientSecretStatusApiResponse =
  /** status 200 OK */ KeycloakClientSecret;
export type PatchAppthrustDevV1NamespacedKeycloakClientSecretStatusApiArg = {
  /** name of the KeycloakClientSecret */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedKeycloakKeyIdApiResponse = /** status 200 OK */ DevAppthrustV1KeycloakKeyIdList;
export type ListAppthrustDevV1NamespacedKeycloakKeyIdApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedKeycloakKeyIdApiResponse = /** status 200 OK */
  | KeycloakKeyId
  | /** status 201 Created */ KeycloakKeyId
  | /** status 202 Accepted */ KeycloakKeyId;
export type CreateAppthrustDevV1NamespacedKeycloakKeyIdApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakKeyId: KeycloakKeyId;
};
export type DeleteAppthrustDevV1CollectionNamespacedKeycloakKeyIdApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedKeycloakKeyIdApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedKeycloakKeyIdApiResponse = /** status 200 OK */ KeycloakKeyId;
export type ReadAppthrustDevV1NamespacedKeycloakKeyIdApiArg = {
  /** name of the KeycloakKeyId */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedKeycloakKeyIdApiResponse = /** status 200 OK */
  | KeycloakKeyId
  | /** status 201 Created */ KeycloakKeyId;
export type ReplaceAppthrustDevV1NamespacedKeycloakKeyIdApiArg = {
  /** name of the KeycloakKeyId */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakKeyId: KeycloakKeyId;
};
export type DeleteAppthrustDevV1NamespacedKeycloakKeyIdApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedKeycloakKeyIdApiArg = {
  /** name of the KeycloakKeyId */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedKeycloakKeyIdApiResponse = /** status 200 OK */ KeycloakKeyId;
export type PatchAppthrustDevV1NamespacedKeycloakKeyIdApiArg = {
  /** name of the KeycloakKeyId */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedKeycloakKeyIdStatusApiResponse = /** status 200 OK */ KeycloakKeyId;
export type ReadAppthrustDevV1NamespacedKeycloakKeyIdStatusApiArg = {
  /** name of the KeycloakKeyId */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedKeycloakKeyIdStatusApiResponse = /** status 200 OK */
  | KeycloakKeyId
  | /** status 201 Created */ KeycloakKeyId;
export type ReplaceAppthrustDevV1NamespacedKeycloakKeyIdStatusApiArg = {
  /** name of the KeycloakKeyId */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakKeyId: KeycloakKeyId;
};
export type PatchAppthrustDevV1NamespacedKeycloakKeyIdStatusApiResponse = /** status 200 OK */ KeycloakKeyId;
export type PatchAppthrustDevV1NamespacedKeycloakKeyIdStatusApiArg = {
  /** name of the KeycloakKeyId */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse =
  /** status 200 OK */ DevAppthrustV1KeycloakPasswordInitList;
export type ListAppthrustDevV1NamespacedKeycloakPasswordInitApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse = /** status 200 OK */
  | KeycloakPasswordInit
  | /** status 201 Created */ KeycloakPasswordInit
  | /** status 202 Accepted */ KeycloakPasswordInit;
export type CreateAppthrustDevV1NamespacedKeycloakPasswordInitApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakPasswordInit: KeycloakPasswordInit;
};
export type DeleteAppthrustDevV1CollectionNamespacedKeycloakPasswordInitApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedKeycloakPasswordInitApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse = /** status 200 OK */ KeycloakPasswordInit;
export type ReadAppthrustDevV1NamespacedKeycloakPasswordInitApiArg = {
  /** name of the KeycloakPasswordInit */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse = /** status 200 OK */
  | KeycloakPasswordInit
  | /** status 201 Created */ KeycloakPasswordInit;
export type ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitApiArg = {
  /** name of the KeycloakPasswordInit */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakPasswordInit: KeycloakPasswordInit;
};
export type DeleteAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedKeycloakPasswordInitApiArg = {
  /** name of the KeycloakPasswordInit */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse = /** status 200 OK */ KeycloakPasswordInit;
export type PatchAppthrustDevV1NamespacedKeycloakPasswordInitApiArg = {
  /** name of the KeycloakPasswordInit */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiResponse =
  /** status 200 OK */ KeycloakPasswordInit;
export type ReadAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiArg = {
  /** name of the KeycloakPasswordInit */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiResponse = /** status 200 OK */
  | KeycloakPasswordInit
  | /** status 201 Created */ KeycloakPasswordInit;
export type ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiArg = {
  /** name of the KeycloakPasswordInit */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakPasswordInit: KeycloakPasswordInit;
};
export type PatchAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiResponse =
  /** status 200 OK */ KeycloakPasswordInit;
export type PatchAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiArg = {
  /** name of the KeycloakPasswordInit */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse =
  /** status 200 OK */ DevAppthrustV1NextAuthSecretRequestList;
export type ListAppthrustDevV1NamespacedNextAuthSecretRequestApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse = /** status 200 OK */
  | NextAuthSecretRequest
  | /** status 201 Created */ NextAuthSecretRequest
  | /** status 202 Accepted */ NextAuthSecretRequest;
export type CreateAppthrustDevV1NamespacedNextAuthSecretRequestApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1NextAuthSecretRequest: NextAuthSecretRequest;
};
export type DeleteAppthrustDevV1CollectionNamespacedNextAuthSecretRequestApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedNextAuthSecretRequestApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse = /** status 200 OK */ NextAuthSecretRequest;
export type ReadAppthrustDevV1NamespacedNextAuthSecretRequestApiArg = {
  /** name of the NextAuthSecretRequest */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse = /** status 200 OK */
  | NextAuthSecretRequest
  | /** status 201 Created */ NextAuthSecretRequest;
export type ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestApiArg = {
  /** name of the NextAuthSecretRequest */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1NextAuthSecretRequest: NextAuthSecretRequest;
};
export type DeleteAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedNextAuthSecretRequestApiArg = {
  /** name of the NextAuthSecretRequest */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse = /** status 200 OK */ NextAuthSecretRequest;
export type PatchAppthrustDevV1NamespacedNextAuthSecretRequestApiArg = {
  /** name of the NextAuthSecretRequest */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiResponse =
  /** status 200 OK */ NextAuthSecretRequest;
export type ReadAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiArg = {
  /** name of the NextAuthSecretRequest */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiResponse = /** status 200 OK */
  | NextAuthSecretRequest
  | /** status 201 Created */ NextAuthSecretRequest;
export type ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiArg = {
  /** name of the NextAuthSecretRequest */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1NextAuthSecretRequest: NextAuthSecretRequest;
};
export type PatchAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiResponse =
  /** status 200 OK */ NextAuthSecretRequest;
export type PatchAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiArg = {
  /** name of the NextAuthSecretRequest */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedProjectApiResponse = /** status 200 OK */ DevAppthrustV1ProjectList;
export type ListAppthrustDevV1NamespacedProjectApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedProjectApiResponse = /** status 200 OK */
  | Project
  | /** status 201 Created */ Project
  | /** status 202 Accepted */ Project;
export type CreateAppthrustDevV1NamespacedProjectApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Project: Project;
};
export type DeleteAppthrustDevV1CollectionNamespacedProjectApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedProjectApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedProjectApiResponse = /** status 200 OK */ Project;
export type ReadAppthrustDevV1NamespacedProjectApiArg = {
  /** name of the Project */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedProjectApiResponse = /** status 200 OK */
  | Project
  | /** status 201 Created */ Project;
export type ReplaceAppthrustDevV1NamespacedProjectApiArg = {
  /** name of the Project */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Project: Project;
};
export type DeleteAppthrustDevV1NamespacedProjectApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedProjectApiArg = {
  /** name of the Project */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedProjectApiResponse = /** status 200 OK */ Project;
export type PatchAppthrustDevV1NamespacedProjectApiArg = {
  /** name of the Project */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedProjectStatusApiResponse = /** status 200 OK */ Project;
export type ReadAppthrustDevV1NamespacedProjectStatusApiArg = {
  /** name of the Project */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedProjectStatusApiResponse = /** status 200 OK */
  | Project
  | /** status 201 Created */ Project;
export type ReplaceAppthrustDevV1NamespacedProjectStatusApiArg = {
  /** name of the Project */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Project: Project;
};
export type PatchAppthrustDevV1NamespacedProjectStatusApiResponse = /** status 200 OK */ Project;
export type PatchAppthrustDevV1NamespacedProjectStatusApiArg = {
  /** name of the Project */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedReleaseChannelApiResponse =
  /** status 200 OK */ DevAppthrustV1ReleaseChannelList;
export type ListAppthrustDevV1NamespacedReleaseChannelApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedReleaseChannelApiResponse = /** status 200 OK */
  | ReleaseChannel
  | /** status 201 Created */ ReleaseChannel
  | /** status 202 Accepted */ ReleaseChannel;
export type CreateAppthrustDevV1NamespacedReleaseChannelApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ReleaseChannel: ReleaseChannel;
};
export type DeleteAppthrustDevV1CollectionNamespacedReleaseChannelApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedReleaseChannelApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedReleaseChannelApiResponse = /** status 200 OK */ ReleaseChannel;
export type ReadAppthrustDevV1NamespacedReleaseChannelApiArg = {
  /** name of the ReleaseChannel */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedReleaseChannelApiResponse = /** status 200 OK */
  | ReleaseChannel
  | /** status 201 Created */ ReleaseChannel;
export type ReplaceAppthrustDevV1NamespacedReleaseChannelApiArg = {
  /** name of the ReleaseChannel */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ReleaseChannel: ReleaseChannel;
};
export type DeleteAppthrustDevV1NamespacedReleaseChannelApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedReleaseChannelApiArg = {
  /** name of the ReleaseChannel */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedReleaseChannelApiResponse = /** status 200 OK */ ReleaseChannel;
export type PatchAppthrustDevV1NamespacedReleaseChannelApiArg = {
  /** name of the ReleaseChannel */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedReleaseChannelStatusApiResponse = /** status 200 OK */ ReleaseChannel;
export type ReadAppthrustDevV1NamespacedReleaseChannelStatusApiArg = {
  /** name of the ReleaseChannel */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedReleaseChannelStatusApiResponse = /** status 200 OK */
  | ReleaseChannel
  | /** status 201 Created */ ReleaseChannel;
export type ReplaceAppthrustDevV1NamespacedReleaseChannelStatusApiArg = {
  /** name of the ReleaseChannel */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ReleaseChannel: ReleaseChannel;
};
export type PatchAppthrustDevV1NamespacedReleaseChannelStatusApiResponse = /** status 200 OK */ ReleaseChannel;
export type PatchAppthrustDevV1NamespacedReleaseChannelStatusApiArg = {
  /** name of the ReleaseChannel */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedResourceValueSyncApiResponse =
  /** status 200 OK */ DevAppthrustV1ResourceValueSyncList;
export type ListAppthrustDevV1NamespacedResourceValueSyncApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedResourceValueSyncApiResponse = /** status 200 OK */
  | ResourceValueSync
  | /** status 201 Created */ ResourceValueSync
  | /** status 202 Accepted */ ResourceValueSync;
export type CreateAppthrustDevV1NamespacedResourceValueSyncApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ResourceValueSync: ResourceValueSync;
};
export type DeleteAppthrustDevV1CollectionNamespacedResourceValueSyncApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedResourceValueSyncApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedResourceValueSyncApiResponse = /** status 200 OK */ ResourceValueSync;
export type ReadAppthrustDevV1NamespacedResourceValueSyncApiArg = {
  /** name of the ResourceValueSync */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedResourceValueSyncApiResponse = /** status 200 OK */
  | ResourceValueSync
  | /** status 201 Created */ ResourceValueSync;
export type ReplaceAppthrustDevV1NamespacedResourceValueSyncApiArg = {
  /** name of the ResourceValueSync */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ResourceValueSync: ResourceValueSync;
};
export type DeleteAppthrustDevV1NamespacedResourceValueSyncApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedResourceValueSyncApiArg = {
  /** name of the ResourceValueSync */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedResourceValueSyncApiResponse = /** status 200 OK */ ResourceValueSync;
export type PatchAppthrustDevV1NamespacedResourceValueSyncApiArg = {
  /** name of the ResourceValueSync */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedResourceValueSyncStatusApiResponse = /** status 200 OK */ ResourceValueSync;
export type ReadAppthrustDevV1NamespacedResourceValueSyncStatusApiArg = {
  /** name of the ResourceValueSync */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedResourceValueSyncStatusApiResponse = /** status 200 OK */
  | ResourceValueSync
  | /** status 201 Created */ ResourceValueSync;
export type ReplaceAppthrustDevV1NamespacedResourceValueSyncStatusApiArg = {
  /** name of the ResourceValueSync */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ResourceValueSync: ResourceValueSync;
};
export type PatchAppthrustDevV1NamespacedResourceValueSyncStatusApiResponse = /** status 200 OK */ ResourceValueSync;
export type PatchAppthrustDevV1NamespacedResourceValueSyncStatusApiArg = {
  /** name of the ResourceValueSync */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedTfApplyApiResponse = /** status 200 OK */ DevAppthrustV1TfApplyList;
export type ListAppthrustDevV1NamespacedTfApplyApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedTfApplyApiResponse = /** status 200 OK */
  | TfApply
  | /** status 201 Created */ TfApply
  | /** status 202 Accepted */ TfApply;
export type CreateAppthrustDevV1NamespacedTfApplyApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1TfApply: TfApply;
};
export type DeleteAppthrustDevV1CollectionNamespacedTfApplyApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedTfApplyApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedTfApplyApiResponse = /** status 200 OK */ TfApply;
export type ReadAppthrustDevV1NamespacedTfApplyApiArg = {
  /** name of the TfApply */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedTfApplyApiResponse = /** status 200 OK */
  | TfApply
  | /** status 201 Created */ TfApply;
export type ReplaceAppthrustDevV1NamespacedTfApplyApiArg = {
  /** name of the TfApply */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1TfApply: TfApply;
};
export type DeleteAppthrustDevV1NamespacedTfApplyApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedTfApplyApiArg = {
  /** name of the TfApply */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedTfApplyApiResponse = /** status 200 OK */ TfApply;
export type PatchAppthrustDevV1NamespacedTfApplyApiArg = {
  /** name of the TfApply */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedTfApplyStatusApiResponse = /** status 200 OK */ TfApply;
export type ReadAppthrustDevV1NamespacedTfApplyStatusApiArg = {
  /** name of the TfApply */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedTfApplyStatusApiResponse = /** status 200 OK */
  | TfApply
  | /** status 201 Created */ TfApply;
export type ReplaceAppthrustDevV1NamespacedTfApplyStatusApiArg = {
  /** name of the TfApply */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1TfApply: TfApply;
};
export type PatchAppthrustDevV1NamespacedTfApplyStatusApiResponse = /** status 200 OK */ TfApply;
export type PatchAppthrustDevV1NamespacedTfApplyStatusApiArg = {
  /** name of the TfApply */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedTrafficSplittingApiResponse =
  /** status 200 OK */ DevAppthrustV1TrafficSplittingList;
export type ListAppthrustDevV1NamespacedTrafficSplittingApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedTrafficSplittingApiResponse = /** status 200 OK */
  | TrafficSplitting
  | /** status 201 Created */ TrafficSplitting
  | /** status 202 Accepted */ TrafficSplitting;
export type CreateAppthrustDevV1NamespacedTrafficSplittingApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1TrafficSplitting: TrafficSplitting;
};
export type DeleteAppthrustDevV1CollectionNamespacedTrafficSplittingApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedTrafficSplittingApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedTrafficSplittingApiResponse = /** status 200 OK */ TrafficSplitting;
export type ReadAppthrustDevV1NamespacedTrafficSplittingApiArg = {
  /** name of the TrafficSplitting */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedTrafficSplittingApiResponse = /** status 200 OK */
  | TrafficSplitting
  | /** status 201 Created */ TrafficSplitting;
export type ReplaceAppthrustDevV1NamespacedTrafficSplittingApiArg = {
  /** name of the TrafficSplitting */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1TrafficSplitting: TrafficSplitting;
};
export type DeleteAppthrustDevV1NamespacedTrafficSplittingApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedTrafficSplittingApiArg = {
  /** name of the TrafficSplitting */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedTrafficSplittingApiResponse = /** status 200 OK */ TrafficSplitting;
export type PatchAppthrustDevV1NamespacedTrafficSplittingApiArg = {
  /** name of the TrafficSplitting */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedTrafficSplittingStatusApiResponse = /** status 200 OK */ TrafficSplitting;
export type ReadAppthrustDevV1NamespacedTrafficSplittingStatusApiArg = {
  /** name of the TrafficSplitting */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedTrafficSplittingStatusApiResponse = /** status 200 OK */
  | TrafficSplitting
  | /** status 201 Created */ TrafficSplitting;
export type ReplaceAppthrustDevV1NamespacedTrafficSplittingStatusApiArg = {
  /** name of the TrafficSplitting */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1TrafficSplitting: TrafficSplitting;
};
export type PatchAppthrustDevV1NamespacedTrafficSplittingStatusApiResponse = /** status 200 OK */ TrafficSplitting;
export type PatchAppthrustDevV1NamespacedTrafficSplittingStatusApiArg = {
  /** name of the TrafficSplitting */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedVpcDataApiResponse = /** status 200 OK */ DevAppthrustV1VpcDataList;
export type ListAppthrustDevV1NamespacedVpcDataApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedVpcDataApiResponse = /** status 200 OK */
  | VpcData
  | /** status 201 Created */ VpcData
  | /** status 202 Accepted */ VpcData;
export type CreateAppthrustDevV1NamespacedVpcDataApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1VpcData: VpcData;
};
export type DeleteAppthrustDevV1CollectionNamespacedVpcDataApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedVpcDataApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedVpcDataApiResponse = /** status 200 OK */ VpcData;
export type ReadAppthrustDevV1NamespacedVpcDataApiArg = {
  /** name of the VpcData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedVpcDataApiResponse = /** status 200 OK */
  | VpcData
  | /** status 201 Created */ VpcData;
export type ReplaceAppthrustDevV1NamespacedVpcDataApiArg = {
  /** name of the VpcData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1VpcData: VpcData;
};
export type DeleteAppthrustDevV1NamespacedVpcDataApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedVpcDataApiArg = {
  /** name of the VpcData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedVpcDataApiResponse = /** status 200 OK */ VpcData;
export type PatchAppthrustDevV1NamespacedVpcDataApiArg = {
  /** name of the VpcData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedVpcDataStatusApiResponse = /** status 200 OK */ VpcData;
export type ReadAppthrustDevV1NamespacedVpcDataStatusApiArg = {
  /** name of the VpcData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedVpcDataStatusApiResponse = /** status 200 OK */
  | VpcData
  | /** status 201 Created */ VpcData;
export type ReplaceAppthrustDevV1NamespacedVpcDataStatusApiArg = {
  /** name of the VpcData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1VpcData: VpcData;
};
export type PatchAppthrustDevV1NamespacedVpcDataStatusApiResponse = /** status 200 OK */ VpcData;
export type PatchAppthrustDevV1NamespacedVpcDataStatusApiArg = {
  /** name of the VpcData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedVpcApiResponse = /** status 200 OK */ DevAppthrustV1VpcList;
export type ListAppthrustDevV1NamespacedVpcApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedVpcApiResponse = /** status 200 OK */
  | Vpc
  | /** status 201 Created */ Vpc
  | /** status 202 Accepted */ Vpc;
export type CreateAppthrustDevV1NamespacedVpcApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Vpc: Vpc;
};
export type DeleteAppthrustDevV1CollectionNamespacedVpcApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedVpcApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedVpcApiResponse = /** status 200 OK */ Vpc;
export type ReadAppthrustDevV1NamespacedVpcApiArg = {
  /** name of the Vpc */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedVpcApiResponse = /** status 200 OK */ Vpc | /** status 201 Created */ Vpc;
export type ReplaceAppthrustDevV1NamespacedVpcApiArg = {
  /** name of the Vpc */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Vpc: Vpc;
};
export type DeleteAppthrustDevV1NamespacedVpcApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedVpcApiArg = {
  /** name of the Vpc */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedVpcApiResponse = /** status 200 OK */ Vpc;
export type PatchAppthrustDevV1NamespacedVpcApiArg = {
  /** name of the Vpc */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedVpcStatusApiResponse = /** status 200 OK */ Vpc;
export type ReadAppthrustDevV1NamespacedVpcStatusApiArg = {
  /** name of the Vpc */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedVpcStatusApiResponse = /** status 200 OK */
  | Vpc
  | /** status 201 Created */ Vpc;
export type ReplaceAppthrustDevV1NamespacedVpcStatusApiArg = {
  /** name of the Vpc */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Vpc: Vpc;
};
export type PatchAppthrustDevV1NamespacedVpcStatusApiResponse = /** status 200 OK */ Vpc;
export type PatchAppthrustDevV1NamespacedVpcStatusApiArg = {
  /** name of the Vpc */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWafApiResponse = /** status 200 OK */ DevAppthrustV1WafList;
export type ListAppthrustDevV1NamespacedWafApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWafApiResponse = /** status 200 OK */
  | Waf
  | /** status 201 Created */ Waf
  | /** status 202 Accepted */ Waf;
export type CreateAppthrustDevV1NamespacedWafApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Waf: Waf;
};
export type DeleteAppthrustDevV1CollectionNamespacedWafApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWafApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWafApiResponse = /** status 200 OK */ Waf;
export type ReadAppthrustDevV1NamespacedWafApiArg = {
  /** name of the Waf */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWafApiResponse = /** status 200 OK */ Waf | /** status 201 Created */ Waf;
export type ReplaceAppthrustDevV1NamespacedWafApiArg = {
  /** name of the Waf */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Waf: Waf;
};
export type DeleteAppthrustDevV1NamespacedWafApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWafApiArg = {
  /** name of the Waf */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWafApiResponse = /** status 200 OK */ Waf;
export type PatchAppthrustDevV1NamespacedWafApiArg = {
  /** name of the Waf */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWafStatusApiResponse = /** status 200 OK */ Waf;
export type ReadAppthrustDevV1NamespacedWafStatusApiArg = {
  /** name of the Waf */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWafStatusApiResponse = /** status 200 OK */
  | Waf
  | /** status 201 Created */ Waf;
export type ReplaceAppthrustDevV1NamespacedWafStatusApiArg = {
  /** name of the Waf */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Waf: Waf;
};
export type PatchAppthrustDevV1NamespacedWafStatusApiResponse = /** status 200 OK */ Waf;
export type PatchAppthrustDevV1NamespacedWafStatusApiArg = {
  /** name of the Waf */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentBuildFinishedList;
export type ListAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse = /** status 200 OK */
  | WebAppComponentBuildFinished
  | /** status 201 Created */ WebAppComponentBuildFinished
  | /** status 202 Accepted */ WebAppComponentBuildFinished;
export type CreateAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentBuildFinished: WebAppComponentBuildFinished;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildFinishedApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildFinishedApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse =
  /** status 200 OK */ WebAppComponentBuildFinished;
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg = {
  /** name of the WebAppComponentBuildFinished */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse = /** status 200 OK */
  | WebAppComponentBuildFinished
  | /** status 201 Created */ WebAppComponentBuildFinished;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg = {
  /** name of the WebAppComponentBuildFinished */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentBuildFinished: WebAppComponentBuildFinished;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg = {
  /** name of the WebAppComponentBuildFinished */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse =
  /** status 200 OK */ WebAppComponentBuildFinished;
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg = {
  /** name of the WebAppComponentBuildFinished */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiResponse =
  /** status 200 OK */ WebAppComponentBuildFinished;
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiArg = {
  /** name of the WebAppComponentBuildFinished */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiResponse = /** status 200 OK */
  | WebAppComponentBuildFinished
  | /** status 201 Created */ WebAppComponentBuildFinished;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiArg = {
  /** name of the WebAppComponentBuildFinished */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentBuildFinished: WebAppComponentBuildFinished;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiResponse =
  /** status 200 OK */ WebAppComponentBuildFinished;
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiArg = {
  /** name of the WebAppComponentBuildFinished */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentBuildApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentBuildList;
export type ListAppthrustDevV1NamespacedWebAppComponentBuildApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentBuildApiResponse = /** status 200 OK */
  | WebAppComponentBuild
  | /** status 201 Created */ WebAppComponentBuild
  | /** status 202 Accepted */ WebAppComponentBuild;
export type CreateAppthrustDevV1NamespacedWebAppComponentBuildApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentBuild: WebAppComponentBuild;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildApiResponse = /** status 200 OK */ WebAppComponentBuild;
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildApiArg = {
  /** name of the WebAppComponentBuild */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildApiResponse = /** status 200 OK */
  | WebAppComponentBuild
  | /** status 201 Created */ WebAppComponentBuild;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildApiArg = {
  /** name of the WebAppComponentBuild */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentBuild: WebAppComponentBuild;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentBuildApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentBuildApiArg = {
  /** name of the WebAppComponentBuild */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildApiResponse = /** status 200 OK */ WebAppComponentBuild;
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildApiArg = {
  /** name of the WebAppComponentBuild */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildStatusApiResponse =
  /** status 200 OK */ WebAppComponentBuild;
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildStatusApiArg = {
  /** name of the WebAppComponentBuild */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildStatusApiResponse = /** status 200 OK */
  | WebAppComponentBuild
  | /** status 201 Created */ WebAppComponentBuild;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildStatusApiArg = {
  /** name of the WebAppComponentBuild */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentBuild: WebAppComponentBuild;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildStatusApiResponse =
  /** status 200 OK */ WebAppComponentBuild;
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildStatusApiArg = {
  /** name of the WebAppComponentBuild */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentDeploymentList;
export type ListAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse = /** status 200 OK */
  | WebAppComponentDeployment
  | /** status 201 Created */ WebAppComponentDeployment
  | /** status 202 Accepted */ WebAppComponentDeployment;
export type CreateAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentDeployment: WebAppComponentDeployment;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentDeploymentApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentDeploymentApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse =
  /** status 200 OK */ WebAppComponentDeployment;
export type ReadAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg = {
  /** name of the WebAppComponentDeployment */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse = /** status 200 OK */
  | WebAppComponentDeployment
  | /** status 201 Created */ WebAppComponentDeployment;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg = {
  /** name of the WebAppComponentDeployment */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentDeployment: WebAppComponentDeployment;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg = {
  /** name of the WebAppComponentDeployment */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse =
  /** status 200 OK */ WebAppComponentDeployment;
export type PatchAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg = {
  /** name of the WebAppComponentDeployment */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiResponse =
  /** status 200 OK */ WebAppComponentDeployment;
export type ReadAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiArg = {
  /** name of the WebAppComponentDeployment */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiResponse = /** status 200 OK */
  | WebAppComponentDeployment
  | /** status 201 Created */ WebAppComponentDeployment;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiArg = {
  /** name of the WebAppComponentDeployment */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentDeployment: WebAppComponentDeployment;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiResponse =
  /** status 200 OK */ WebAppComponentDeployment;
export type PatchAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiArg = {
  /** name of the WebAppComponentDeployment */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentGatewayConnectionList;
export type ListAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse = /** status 200 OK */
  | WebAppComponentGatewayConnection
  | /** status 201 Created */ WebAppComponentGatewayConnection
  | /** status 202 Accepted */ WebAppComponentGatewayConnection;
export type CreateAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentGatewayConnection: WebAppComponentGatewayConnection;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentGatewayConnectionApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentGatewayConnectionApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse =
  /** status 200 OK */ WebAppComponentGatewayConnection;
export type ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg = {
  /** name of the WebAppComponentGatewayConnection */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse = /** status 200 OK */
  | WebAppComponentGatewayConnection
  | /** status 201 Created */ WebAppComponentGatewayConnection;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg = {
  /** name of the WebAppComponentGatewayConnection */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentGatewayConnection: WebAppComponentGatewayConnection;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg = {
  /** name of the WebAppComponentGatewayConnection */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse =
  /** status 200 OK */ WebAppComponentGatewayConnection;
export type PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg = {
  /** name of the WebAppComponentGatewayConnection */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiResponse =
  /** status 200 OK */ WebAppComponentGatewayConnection;
export type ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiArg = {
  /** name of the WebAppComponentGatewayConnection */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiResponse = /** status 200 OK */
  | WebAppComponentGatewayConnection
  | /** status 201 Created */ WebAppComponentGatewayConnection;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiArg = {
  /** name of the WebAppComponentGatewayConnection */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentGatewayConnection: WebAppComponentGatewayConnection;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiResponse =
  /** status 200 OK */ WebAppComponentGatewayConnection;
export type PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiArg = {
  /** name of the WebAppComponentGatewayConnection */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentPipelineList;
export type ListAppthrustDevV1NamespacedWebAppComponentPipelineApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse = /** status 200 OK */
  | WebAppComponentPipeline
  | /** status 201 Created */ WebAppComponentPipeline
  | /** status 202 Accepted */ WebAppComponentPipeline;
export type CreateAppthrustDevV1NamespacedWebAppComponentPipelineApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentPipeline: WebAppComponentPipeline;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentPipelineApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentPipelineApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse =
  /** status 200 OK */ WebAppComponentPipeline;
export type ReadAppthrustDevV1NamespacedWebAppComponentPipelineApiArg = {
  /** name of the WebAppComponentPipeline */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse = /** status 200 OK */
  | WebAppComponentPipeline
  | /** status 201 Created */ WebAppComponentPipeline;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineApiArg = {
  /** name of the WebAppComponentPipeline */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentPipeline: WebAppComponentPipeline;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentPipelineApiArg = {
  /** name of the WebAppComponentPipeline */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse =
  /** status 200 OK */ WebAppComponentPipeline;
export type PatchAppthrustDevV1NamespacedWebAppComponentPipelineApiArg = {
  /** name of the WebAppComponentPipeline */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiResponse =
  /** status 200 OK */ WebAppComponentPipeline;
export type ReadAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiArg = {
  /** name of the WebAppComponentPipeline */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiResponse = /** status 200 OK */
  | WebAppComponentPipeline
  | /** status 201 Created */ WebAppComponentPipeline;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiArg = {
  /** name of the WebAppComponentPipeline */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentPipeline: WebAppComponentPipeline;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiResponse =
  /** status 200 OK */ WebAppComponentPipeline;
export type PatchAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiArg = {
  /** name of the WebAppComponentPipeline */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentReleaseChannelBuildConfigList;
export type ListAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse = /** status 200 OK */
  | WebAppComponentReleaseChannelBuildConfig
  | /** status 201 Created */ WebAppComponentReleaseChannelBuildConfig
  | /** status 202 Accepted */ WebAppComponentReleaseChannelBuildConfig;
export type CreateAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentReleaseChannelBuildConfig: WebAppComponentReleaseChannelBuildConfig;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentReleaseChannelBuildConfigApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentReleaseChannelBuildConfigApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse =
  /** status 200 OK */ WebAppComponentReleaseChannelBuildConfig;
export type ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg = {
  /** name of the WebAppComponentReleaseChannelBuildConfig */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse = /** status 200 OK */
  | WebAppComponentReleaseChannelBuildConfig
  | /** status 201 Created */ WebAppComponentReleaseChannelBuildConfig;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg = {
  /** name of the WebAppComponentReleaseChannelBuildConfig */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentReleaseChannelBuildConfig: WebAppComponentReleaseChannelBuildConfig;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg = {
  /** name of the WebAppComponentReleaseChannelBuildConfig */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse =
  /** status 200 OK */ WebAppComponentReleaseChannelBuildConfig;
export type PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg = {
  /** name of the WebAppComponentReleaseChannelBuildConfig */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiResponse =
  /** status 200 OK */ WebAppComponentReleaseChannelBuildConfig;
export type ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiArg = {
  /** name of the WebAppComponentReleaseChannelBuildConfig */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiResponse =
  /** status 200 OK */
    | WebAppComponentReleaseChannelBuildConfig
    | /** status 201 Created */ WebAppComponentReleaseChannelBuildConfig;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiArg = {
  /** name of the WebAppComponentReleaseChannelBuildConfig */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentReleaseChannelBuildConfig: WebAppComponentReleaseChannelBuildConfig;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiResponse =
  /** status 200 OK */ WebAppComponentReleaseChannelBuildConfig;
export type PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiArg = {
  /** name of the WebAppComponentReleaseChannelBuildConfig */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentRevisionList;
export type ListAppthrustDevV1NamespacedWebAppComponentRevisionApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse = /** status 200 OK */
  | WebAppComponentRevision
  | /** status 201 Created */ WebAppComponentRevision
  | /** status 202 Accepted */ WebAppComponentRevision;
export type CreateAppthrustDevV1NamespacedWebAppComponentRevisionApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentRevision: WebAppComponentRevision;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentRevisionApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentRevisionApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse =
  /** status 200 OK */ WebAppComponentRevision;
export type ReadAppthrustDevV1NamespacedWebAppComponentRevisionApiArg = {
  /** name of the WebAppComponentRevision */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse = /** status 200 OK */
  | WebAppComponentRevision
  | /** status 201 Created */ WebAppComponentRevision;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionApiArg = {
  /** name of the WebAppComponentRevision */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentRevision: WebAppComponentRevision;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentRevisionApiArg = {
  /** name of the WebAppComponentRevision */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse =
  /** status 200 OK */ WebAppComponentRevision;
export type PatchAppthrustDevV1NamespacedWebAppComponentRevisionApiArg = {
  /** name of the WebAppComponentRevision */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiResponse =
  /** status 200 OK */ WebAppComponentRevision;
export type ReadAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiArg = {
  /** name of the WebAppComponentRevision */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiResponse = /** status 200 OK */
  | WebAppComponentRevision
  | /** status 201 Created */ WebAppComponentRevision;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiArg = {
  /** name of the WebAppComponentRevision */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentRevision: WebAppComponentRevision;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiResponse =
  /** status 200 OK */ WebAppComponentRevision;
export type PatchAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiArg = {
  /** name of the WebAppComponentRevision */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentList;
export type ListAppthrustDevV1NamespacedWebAppComponentApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentApiResponse = /** status 200 OK */
  | WebAppComponent
  | /** status 201 Created */ WebAppComponent
  | /** status 202 Accepted */ WebAppComponent;
export type CreateAppthrustDevV1NamespacedWebAppComponentApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponent: WebAppComponent;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentApiResponse = /** status 200 OK */ WebAppComponent;
export type ReadAppthrustDevV1NamespacedWebAppComponentApiArg = {
  /** name of the WebAppComponent */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentApiResponse = /** status 200 OK */
  | WebAppComponent
  | /** status 201 Created */ WebAppComponent;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentApiArg = {
  /** name of the WebAppComponent */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponent: WebAppComponent;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentApiArg = {
  /** name of the WebAppComponent */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentApiResponse = /** status 200 OK */ WebAppComponent;
export type PatchAppthrustDevV1NamespacedWebAppComponentApiArg = {
  /** name of the WebAppComponent */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentStatusApiResponse = /** status 200 OK */ WebAppComponent;
export type ReadAppthrustDevV1NamespacedWebAppComponentStatusApiArg = {
  /** name of the WebAppComponent */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentStatusApiResponse = /** status 200 OK */
  | WebAppComponent
  | /** status 201 Created */ WebAppComponent;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentStatusApiArg = {
  /** name of the WebAppComponent */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponent: WebAppComponent;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentStatusApiResponse = /** status 200 OK */ WebAppComponent;
export type PatchAppthrustDevV1NamespacedWebAppComponentStatusApiArg = {
  /** name of the WebAppComponent */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NextAuthSecretRequestForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1NextAuthSecretRequestList;
export type ListAppthrustDevV1NextAuthSecretRequestForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1ProjectForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1ProjectList;
export type ListAppthrustDevV1ProjectForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1ReleaseChannelForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1ReleaseChannelList;
export type ListAppthrustDevV1ReleaseChannelForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1ResourceValueSyncForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1ResourceValueSyncList;
export type ListAppthrustDevV1ResourceValueSyncForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1TfApplyForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1TfApplyList;
export type ListAppthrustDevV1TfApplyForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1TrafficSplittingForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1TrafficSplittingList;
export type ListAppthrustDevV1TrafficSplittingForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1VpcDataForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1VpcDataList;
export type ListAppthrustDevV1VpcDataForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1VpcForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1VpcList;
export type ListAppthrustDevV1VpcForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WafForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1WafList;
export type ListAppthrustDevV1WafForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentBuildFinishedForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentBuildFinishedList;
export type ListAppthrustDevV1WebAppComponentBuildFinishedForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentBuildForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentBuildList;
export type ListAppthrustDevV1WebAppComponentBuildForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentDeploymentForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentDeploymentList;
export type ListAppthrustDevV1WebAppComponentDeploymentForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentGatewayConnectionForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentGatewayConnectionList;
export type ListAppthrustDevV1WebAppComponentGatewayConnectionForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentPipelineForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentPipelineList;
export type ListAppthrustDevV1WebAppComponentPipelineForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentReleaseChannelBuildConfigForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentReleaseChannelBuildConfigList;
export type ListAppthrustDevV1WebAppComponentReleaseChannelBuildConfigForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentRevisionForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentRevisionList;
export type ListAppthrustDevV1WebAppComponentRevisionForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentList;
export type ListAppthrustDevV1WebAppComponentForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type IoK8SApimachineryPkgApisMetaV1Time = string;
export type IoK8SApimachineryPkgApisMetaV1FieldsV1 = object;
export type IoK8SApimachineryPkgApisMetaV1ManagedFieldsEntry = {
  apiVersion?: string | undefined;
  fieldsType?: string | undefined;
  fieldsV1?: IoK8SApimachineryPkgApisMetaV1FieldsV1 | undefined;
  manager?: string | undefined;
  operation?: string | undefined;
  subresource?: string | undefined;
  time?: IoK8SApimachineryPkgApisMetaV1Time | undefined;
};
export type IoK8SApimachineryPkgApisMetaV1OwnerReference = {
  apiVersion: string;
  blockOwnerDeletion?: boolean | undefined;
  controller?: boolean | undefined;
  kind: string;
  name: string;
  uid: string;
};
export type IoK8SApimachineryPkgApisMetaV1ObjectMeta = {
  annotations?:
    | {
        [key: string]: string;
      }
    | undefined;
  creationTimestamp?: IoK8SApimachineryPkgApisMetaV1Time | undefined;
  deletionGracePeriodSeconds?: number | undefined;
  deletionTimestamp?: IoK8SApimachineryPkgApisMetaV1Time | undefined;
  finalizers?: string[] | undefined;
  generateName?: string | undefined;
  generation?: number | undefined;
  labels?:
    | {
        [key: string]: string;
      }
    | undefined;
  managedFields?: IoK8SApimachineryPkgApisMetaV1ManagedFieldsEntry[] | undefined;
  name?: string | undefined;
  namespace?: string | undefined;
  ownerReferences?: IoK8SApimachineryPkgApisMetaV1OwnerReference[] | undefined;
  resourceVersion?: string | undefined;
  selfLink?: string | undefined;
  uid?: string | undefined;
};
export type AlbGatewayParameters = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    create_s3_bucket?: (boolean | null) | undefined;
    deletion_protection?: (boolean | null) | undefined;
    health_check_node_port_service?:
      | ({
          name: string;
          namespace: string;
        } | null)
      | undefined;
    idle_timeout_seconds?: (number | null) | undefined;
    s3_access_logs_prefix?: (string | null) | undefined;
    s3_bucket_name?: (string | null) | undefined;
    scheme: 'internal' | 'internet-facing';
    shield_advanced_protection?: (boolean | null) | undefined;
    subnet_ids?: (string[] | null) | undefined;
    tags?: (string | null) | undefined;
    waf_acl_id?: (string | null) | undefined;
    wafv2_acl_arn?: (string | null) | undefined;
  };
  status?: (object | null) | undefined;
};
export type IoK8SApimachineryPkgApisMetaV1ListMeta = {
  continue?: string | undefined;
  remainingItemCount?: number | undefined;
  resourceVersion?: string | undefined;
  selfLink?: string | undefined;
};
export type DevAppthrustV1AlbGatewayParametersList = {
  apiVersion?: string | undefined;
  items: AlbGatewayParameters[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type AwsRoute53Zone = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    domainName: string;
    forceDelete: boolean;
    secretEnvRef?:
      | ({
          name: string;
          namespace: string;
        } | null)
      | undefined;
    vpcs: {
      vpcId: string;
      vpcRegion: string;
    }[];
    zoneId?: (string | null) | undefined;
  };
  status?:
    | ({
        awsCallerIdentity?: (string | null) | undefined;
        conditions: {
          lastTransitionTime: string;
          message: string;
          observedGeneration?: (number | null) | undefined;
          reason:
            | 'Pending'
            | 'ProviderAuthFailed'
            | 'KubernetesPermissionDenied'
            | 'CreationSucceeded'
            | 'CreationFailed'
            | 'DelegationSucceeded'
            | 'DelegationFailed'
            | 'ZoneMissing'
            | 'ProvidersReconciled';
          status: 'True' | 'False' | 'Unknown';
          type: 'Accepted' | 'Failed' | 'Ready' | 'Modified';
        }[];
        progressing: 'WaitingForController' | 'ZoneCreation' | 'ZoneReference' | 'ZoneDelegation' | 'InvalidSpec';
        progressingStatus: 'Pending' | 'InProgress' | 'Completed' | 'Failed';
        zoneId?: (string | null) | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1AwsRoute53ZoneList = {
  apiVersion?: string | undefined;
  items: AwsRoute53Zone[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type Cert = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    dependencies?:
      | (
          | {
              gvk: {
                group: string;
                kind: string;
                version: string;
              };
              name: string;
              namespace: string;
              output_field_name: string;
              status_completed_field_name: string;
            }[]
          | null
        )
      | undefined;
    variables: {
      aws_account_id: string;
      aws_external_id: string;
      domain: string;
      role_name: string;
    };
  };
  status?:
    | ({
        delegated_resource_name?: (string | null) | undefined;
        driver_completed?: (boolean | null) | undefined;
        driver_delegated?: (boolean | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1CertList = {
  apiVersion?: string | undefined;
  items: Cert[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type ContainerImageTag = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    container_repository_id: string;
    name: string;
  };
  status?:
    | ({
        state: 'Reserved' | 'Ready' | 'Canceled';
      } | null)
    | undefined;
};
export type DevAppthrustV1ContainerImageTagList = {
  apiVersion?: string | undefined;
  items: ContainerImageTag[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type ContainerRepository = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    domain: string;
    git_repository_id: string;
    id: string;
    name: string;
    root_directory: string;
    type: 'EcrLocal';
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1ContainerRepositoryList = {
  apiVersion?: string | undefined;
  items: ContainerRepository[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type DnsZone = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    dependencies?:
      | (
          | {
              gvk: {
                group: string;
                kind: string;
                version: string;
              };
              name: string;
              namespace: string;
              output_field_name: string;
              status_completed_field_name: string;
            }[]
          | null
        )
      | undefined;
    variables: {
      assume_role_arn: string;
      aws_external_id: string;
      aws_route53_query_log_retention_in_days: number;
      domain: string;
    };
  };
  status?:
    | ({
        delegated_resource_name?: (string | null) | undefined;
        driver_completed?: (boolean | null) | undefined;
        driver_delegated?: (boolean | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1DnsZoneList = {
  apiVersion?: string | undefined;
  items: DnsZone[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type DnsZoneTransfer = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    dependencies?:
      | (
          | {
              gvk: {
                group: string;
                kind: string;
                version: string;
              };
              name: string;
              namespace: string;
              output_field_name: string;
              status_completed_field_name: string;
            }[]
          | null
        )
      | undefined;
    variables: {
      aws_account_id: string;
      aws_external_id: string;
      parent_domain: string;
      role_name: string;
      subdomain: string;
      ttl: number;
    };
  };
  status?:
    | ({
        delegated_resource_name?: (string | null) | undefined;
        driver_completed?: (boolean | null) | undefined;
        driver_delegated?: (boolean | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1DnsZoneTransferList = {
  apiVersion?: string | undefined;
  items: DnsZoneTransfer[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type Domain = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    description: string;
    dnsProviders: {
      forceDelete: boolean;
      name: string;
      options?:
        | ({
            [key: string]: string;
          } | null)
        | undefined;
      secretEnvRef?:
        | ({
            name: string;
            namespace: string;
          } | null)
        | undefined;
      type: 'awsRoute53Zone';
    }[];
    domainName: string;
  };
  status?:
    | ({
        conditions: {
          lastTransitionTime: string;
          message: string;
          observedGeneration?: (number | null) | undefined;
          reason: 'ProvidersReconciled' | 'Pending';
          status: 'True' | 'False' | 'Unknown';
          type: 'Accepted' | 'Failed' | 'Ready' | 'Modified';
        }[];
      } | null)
    | undefined;
};
export type DevAppthrustV1DomainList = {
  apiVersion?: string | undefined;
  items: Domain[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type Eks = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    assume_role_variables: {
      assume_role_arn: string;
    };
    cluster_deployment_id: string;
    dependencies?:
      | (
          | {
              gvk: {
                group: string;
                kind: string;
                version: string;
              };
              name: string;
              namespace: string;
              output_field_name: string;
              status_completed_field_name: string;
            }[]
          | null
        )
      | undefined;
    eks_addons_variables: {
      add_ons_path_prefix: string;
      add_ons_repo_url: string;
      add_ons_ssh_key: string;
      add_ons_target_revision: string;
    };
    eks_appthrust_variables: {
      appthrust_backend_image_repository: string;
      appthrust_cloud_api_url: string;
      appthrust_default_domain?: (string | null) | undefined;
      appthrust_frontend_image_repository: string;
      appthrust_image_tag: string;
      appthrust_installer_iam_role_name_override?: (string | null) | undefined;
      appthrust_keycloak_jwks_path: string;
      appthrust_organization_id: number;
      appthrust_registry: string;
      appthrust_route53_zone_delegation_iam_role_name?: (string | null) | undefined;
      appthrust_tfstate_s3_bucket_name?: (string | null) | undefined;
      enable_appthrust: boolean;
    };
    eks_auth_variables: {
      cluster_read_only_group_name: string;
      k8s_master_iam_user_arns: string[];
      k8s_namespace_admin_iam_user_arns: {
        [key: string]: string[];
      };
      k8s_read_only_iam_user_arns: string[];
    };
    eks_default_worker_node_variables: {
      cpu_architecture: string;
      karpenter_capacity_types: string[];
      karpenter_provisioner_resource_limits: {
        [key: string]: string;
      };
      managed_nodegroup_capacity_type: string;
      os: string;
      terraform_runtime_cpu_architecture: string;
    };
    eks_dns_record_behaviour_variables: {
      ttl: number;
    };
    eks_dns_variables: {
      additional_domains: string[];
      dns_suffix: string;
      enable_external_dns: boolean;
      primary_domain: string;
    };
    eks_endpoint_variables: {
      cluster_endpoint_public_access_cidrs: string[];
    };
    eks_logging_variables: {
      cluster_enabled_log_types: string[];
      log_s3_bucket_name: string;
    };
    eks_managed_node_variables: {
      dedicated_core_node_instance_types: string[];
      dedicated_core_node_num: number;
      dedicated_tekton_node_instance_types: string[];
      dedicated_tekton_node_num: number;
      dedicated_tf_node_instance_types: string[];
      dedicated_tf_node_num: number;
    };
    eks_mesh_variables: {
      cilium_version: string;
      clustermesh_apiserver_service_type: string;
      enable_clustermesh_apiserver: string;
      enable_gateway_api: boolean;
      ipam_mode: string;
      mesh_network_id: number;
    };
    eks_network_variables: {
      network_base_position: number;
      number_of_network: number;
      private_subnet_ids: string[];
      public_subnet_ids: string[];
    };
    eks_pod_spec_variables: {
      enable_pod_resource_management: boolean;
      ha_replicas: number;
    };
    eks_waf_variables: {
      waf_acl_name: string;
    };
    pending?: (boolean | null) | undefined;
    variables: {
      appthrust_kind: string;
      aws_external_id: string;
      cluster_id: number;
      cluster_name: string;
      infrastructure_id: number;
      region: string;
      tags?:
        | ({
            [key: string]: string;
          } | null)
        | undefined;
    };
  };
  status?:
    | ({
        delegated_resource_name?: (string | null) | undefined;
        driver_completed?: (boolean | null) | undefined;
        driver_delegated?: (boolean | null) | undefined;
        network_calculation_resource_name?: (string | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1EksList = {
  apiVersion?: string | undefined;
  items: Eks[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type HttprouteToIngress = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    gateway_name: string;
    ingress_name: string;
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1HttprouteToIngressList = {
  apiVersion?: string | undefined;
  items: HttprouteToIngress[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type IamData = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    assume_role_arn: string;
    aws_external_id: string;
    region: string;
  };
  status?:
    | ({
        roles?:
          | (
              | {
                  arn: string;
                  path: string;
                  role_id: string;
                  role_name: string;
                  tags: {
                    key: string;
                    value: string;
                  }[];
                }[]
              | null
            )
          | undefined;
        roles_error?: (string | null) | undefined;
        users?:
          | (
              | {
                  arn: string;
                  path: string;
                  tags: {
                    key: string;
                    value: string;
                  }[];
                  user_id: string;
                  user_name: string;
                }[]
              | null
            )
          | undefined;
        users_error?: (string | null) | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1IamDataList = {
  apiVersion?: string | undefined;
  items: IamData[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type Iam = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    dependencies?:
      | (
          | {
              gvk: {
                group: string;
                kind: string;
                version: string;
              };
              name: string;
              namespace: string;
              output_field_name: string;
              status_completed_field_name: string;
            }[]
          | null
        )
      | undefined;
    variables?:
      | ({
          assume_role_arn?: (string | null) | undefined;
          aws_external_id?: (string | null) | undefined;
          infrastructure_id?: (string | null) | undefined;
          prefix?: (string | null) | undefined;
          read_only_iam_user_names?: (string[] | null) | undefined;
          region?: (string | null) | undefined;
        } | null)
      | undefined;
  };
  status?:
    | ({
        delegated_resource_name?: (string | null) | undefined;
        driver_completed?: (boolean | null) | undefined;
        driver_delegated?: (boolean | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1IamList = {
  apiVersion?: string | undefined;
  items: Iam[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type KeycloakClientSecret = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    client_id: string;
    realm: string;
    secret_key: string;
    secret_name: string;
  };
  status?:
    | ({
        created: boolean;
      } | null)
    | undefined;
};
export type DevAppthrustV1KeycloakClientSecretList = {
  apiVersion?: string | undefined;
  items: KeycloakClientSecret[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type KeycloakKeyId = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    realm: string;
    secret_name: string;
  };
  status?:
    | ({
        created: boolean;
      } | null)
    | undefined;
};
export type DevAppthrustV1KeycloakKeyIdList = {
  apiVersion?: string | undefined;
  items: KeycloakKeyId[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type KeycloakPasswordInit = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    secret_name: string;
  };
  status?:
    | ({
        created: boolean;
      } | null)
    | undefined;
};
export type DevAppthrustV1KeycloakPasswordInitList = {
  apiVersion?: string | undefined;
  items: KeycloakPasswordInit[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type IoK8SApimachineryPkgApisMetaV1StatusCause = {
  field?: string | undefined;
  message?: string | undefined;
  reason?: string | undefined;
};
export type IoK8SApimachineryPkgApisMetaV1StatusDetails = {
  causes?: IoK8SApimachineryPkgApisMetaV1StatusCause[] | undefined;
  group?: string | undefined;
  kind?: string | undefined;
  name?: string | undefined;
  retryAfterSeconds?: number | undefined;
  uid?: string | undefined;
};
export type IoK8SApimachineryPkgApisMetaV1Status = {
  apiVersion?: string | undefined;
  code?: number | undefined;
  details?: IoK8SApimachineryPkgApisMetaV1StatusDetails | undefined;
  kind?: string | undefined;
  message?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
  reason?: string | undefined;
  status?: string | undefined;
};
export type IoK8SApimachineryPkgApisMetaV1Preconditions = {
  resourceVersion?: string | undefined;
  uid?: string | undefined;
};
export type IoK8SApimachineryPkgApisMetaV1DeleteOptions = {
  apiVersion?: string | undefined;
  dryRun?: string[] | undefined;
  gracePeriodSeconds?: number | undefined;
  kind?: string | undefined;
  orphanDependents?: boolean | undefined;
  preconditions?: IoK8SApimachineryPkgApisMetaV1Preconditions | undefined;
  propagationPolicy?: string | undefined;
};
export type NextAuthSecretRequest = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    secret_name: string;
  };
  status?:
    | ({
        created: boolean;
      } | null)
    | undefined;
};
export type DevAppthrustV1NextAuthSecretRequestList = {
  apiVersion?: string | undefined;
  items: NextAuthSecretRequest[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type Project = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    name: string;
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1ProjectList = {
  apiVersion?: string | undefined;
  items: Project[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type ReleaseChannel = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    deployment_strategy: string;
    name: string;
    project_id: string;
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1ReleaseChannelList = {
  apiVersion?: string | undefined;
  items: ReleaseChannel[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type ResourceValueSync = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    data_sources: {
      [key: string]: {
        ref: {
          group: string;
          kind: string;
          name: string;
          namespace: string;
          version: string;
        };
        type: 'KubernetesResource';
      };
    };
    sync_configs: {
      [key: string]: {
        datasource: string;
        from_path: string;
        target: {
          ref: {
            group: string;
            kind: string;
            name: string;
            namespace: string;
            version: string;
          };
          type: 'ArgocdAppHelm';
        };
        to_path: string;
      };
    };
  };
  status?:
    | ({
        sync_statuses: {
          [key: string]: {
            completed: boolean;
          };
        };
      } | null)
    | undefined;
};
export type DevAppthrustV1ResourceValueSyncList = {
  apiVersion?: string | undefined;
  items: ResourceValueSync[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type TfApply = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    destroy?: (boolean | null) | undefined;
    force_reapply?: (boolean | null) | undefined;
    pending?: (boolean | null) | undefined;
    ssh_credentials?:
      | ({
          secret_key_name: string;
          secret_name: string;
          secret_namespace: string;
        } | null)
      | undefined;
    terraform_dir?: (string | null) | undefined;
    terraform_git_repository?: (string | null) | undefined;
    terraform_git_revision?: (string | null) | undefined;
    use_ssh?: (boolean | null) | undefined;
    variables_set?:
      | ({
          [key: string]: {
            [key: string]: string;
          };
        } | null)
      | undefined;
  };
  status?:
    | ({
        completed?: (boolean | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
        state?:
          | (('Prepare' | 'PreparationFailed' | 'NotApplied' | 'Applying' | 'AppliedSuccessfully' | 'Failed') | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1TfApplyList = {
  apiVersion?: string | undefined;
  items: TfApply[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type TrafficSplitting = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    project_id: string;
    release_channel_id: string;
    traffics: {
      percent_x10000: number;
      revision?: (number | null) | undefined;
      type: 'RevisionNumber' | 'LatestRevision';
    }[];
    web_app_component_gateway_connection_ref: {
      group: string;
      kind: string;
      name: string;
      namespace: string;
      version: string;
    };
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1TrafficSplittingList = {
  apiVersion?: string | undefined;
  items: TrafficSplitting[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type VpcData = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    assume_role_arn: string;
    aws_external_id: string;
    region: string;
  };
  status?:
    | ({
        list?:
          | (
              | {
                  cidr_block: string;
                  subnets: {
                    cidr_block: string;
                    subnet_id: string;
                  }[];
                  vpc_id: string;
                }[]
              | null
            )
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1VpcDataList = {
  apiVersion?: string | undefined;
  items: VpcData[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type Vpc = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    dependencies?:
      | (
          | {
              gvk: {
                group: string;
                kind: string;
                version: string;
              };
              name: string;
              namespace: string;
              output_field_name: string;
              status_completed_field_name: string;
            }[]
          | null
        )
      | undefined;
    network_segments: number[][];
    organization_name: string;
    private_subnet_cidrs: string[];
    public_subnet_cidrs: string[];
    variables: {
      assume_role_arn: string;
      aws_external_id: string;
      black_domain_list?: (string[] | null) | undefined;
      cloudtrail_s3_bucket_name: string;
      infrastructure_id: string;
      is_multi_region_trail: boolean;
      log_s3_bucket_name: string;
      prefix: string;
      primary_cidr_block: string;
      region: string;
      secondary_cidr_blocks?: (string[] | null) | undefined;
      single_nat_gateway: boolean;
    };
  };
  status?:
    | ({
        delegated_resource_name?: (string | null) | undefined;
        driver_completed?: (boolean | null) | undefined;
        driver_delegated?: (boolean | null) | undefined;
        network_calculation_resource_name?: (string | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1VpcList = {
  apiVersion?: string | undefined;
  items: Vpc[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type Waf = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    dependencies?:
      | (
          | {
              gvk: {
                group: string;
                kind: string;
                version: string;
              };
              name: string;
              namespace: string;
              output_field_name: string;
              status_completed_field_name: string;
            }[]
          | null
        )
      | undefined;
    variables: {
      aws_account_id: string;
      aws_external_id: string;
      role_name: string;
      waf_acl_name: string;
    };
  };
  status?:
    | ({
        delegated_resource_name?: (string | null) | undefined;
        driver_completed?: (boolean | null) | undefined;
        driver_delegated?: (boolean | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1WafList = {
  apiVersion?: string | undefined;
  items: Waf[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponentBuildFinished = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    branch: string;
    container_image_tag_id: string;
    container_image_tag_snapshot: {
      container_repository_id: string;
      name: string;
    };
    container_repository_snapshot: {
      domain: string;
      git_repository_id: string;
      id: string;
      name: string;
      root_directory: string;
      type: 'EcrLocal';
    };
    deployment_id: string;
    pipeline_id: string;
    project_id: string;
    runtime_environment_variables_id: string;
    web_app_component_snapshot: {
      default_build_config: {
        branch: string;
        root_directory: string;
      };
      domains: {
        domain_id: string;
        release_channel_id: string;
        subdomain: string;
      }[];
      git_repository_id: string;
      name: string;
      project_id: string;
    };
  };
  status?:
    | ({
        state: 'WaitForRevisionResource' | 'RevisionResourceCreated';
      } | null)
    | undefined;
};
export type DevAppthrustV1WebAppComponentBuildFinishedList = {
  apiVersion?: string | undefined;
  items: WebAppComponentBuildFinished[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponentBuild = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    branch: string;
    build_time_environment_variables_id: string;
    component_id: string;
    container_image_tag_id: string;
    container_image_tag_snapshot: {
      container_repository_id: string;
      name: string;
    };
    container_repository_snapshot: {
      domain: string;
      git_repository_id: string;
      id: string;
      name: string;
      root_directory: string;
      type: 'EcrLocal';
    };
    deployment_id: string;
    git_commit_hash: string;
    pipeline_id: string;
    project_id: string;
    release_channel_id: string;
    root_directory: string;
    runtime_environment_variables_id: string;
    web_app_component_snapshot: {
      default_build_config: {
        branch: string;
        root_directory: string;
      };
      domains: {
        domain_id: string;
        release_channel_id: string;
        subdomain: string;
      }[];
      git_repository_id: string;
      name: string;
      project_id: string;
    };
  };
  status?:
    | ({
        created_at?: (string | null) | undefined;
        finished_at?: (string | null) | undefined;
        is_success?: (boolean | null) | undefined;
        logs?: (string | null) | undefined;
        message?: (string | null) | undefined;
        reason?: (string | null) | undefined;
        started_at?: (string | null) | undefined;
        state?: (('WaitingForPipelineRunResource' | 'PipelineRunDelegated' | 'PipelineRunFinished') | null) | undefined;
        updated_at?: (string | null) | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1WebAppComponentBuildList = {
  apiVersion?: string | undefined;
  items: WebAppComponentBuild[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponentDeployment = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    branch: string;
    component_id: string;
    deployment_strategy: string;
    parent_ref: {
      name: string;
      namespace: string;
    };
    project_id: string;
    release_channel_id: string;
  };
  status?:
    | ({
        conditions?: (any[] | null) | undefined;
        revision?: (number | null) | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1WebAppComponentDeploymentList = {
  apiVersion?: string | undefined;
  items: WebAppComponentDeployment[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponentGatewayConnection = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    component_id: string;
    gateway_refs: {
      group: string;
      kind: string;
      name: string;
      namespace: string;
      version: string;
    }[];
    project_id: string;
    release_channel_id: string;
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1WebAppComponentGatewayConnectionList = {
  apiVersion?: string | undefined;
  items: WebAppComponentGatewayConnection[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponentPipeline = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    branch: string;
    build_skip: boolean;
    build_time_environment_variables_id: string;
    component_id: string;
    container_image_tag_id: string;
    container_repository_id: string;
    git_commit_hash: string;
    project_id: string;
    release_channel_id: string;
    root_directory: string;
    runtime_environment_variables_id: string;
  };
  status?:
    | ({
        build_id?: (string | null) | undefined;
        build_state?: (('Skipped' | 'WaitingForBuildResource' | 'Building' | 'Finished') | null) | undefined;
        deployment_id?: (string | null) | undefined;
        is_success?: (boolean | null) | undefined;
        revision_id?: (string | null) | undefined;
        revision_state?:
          | (
              | (
                  | 'WaitingForRevisionResource'
                  | 'DeploymentNotFoundByNamespaceAndDiscriminator'
                  | 'DeploymentExistsByNamespaceAndDiscriminator'
                  | 'DeploymentNameDecided'
                  | 'AwaitDeploymentDiscrimination'
                  | 'DeploymentExistsByTrueDiscriminatedLabel'
                  | 'Provisioning'
                  | 'Finished'
                )
              | null
            )
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1WebAppComponentPipelineList = {
  apiVersion?: string | undefined;
  items: WebAppComponentPipeline[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponentReleaseChannelBuildConfig = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    branch?: (string | null) | undefined;
    component_id: string;
    deployment_strategy: 'Production' | 'Development';
    project_id: string;
    release_channel_id: string;
    root_directory: string;
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1WebAppComponentReleaseChannelBuildConfigList = {
  apiVersion?: string | undefined;
  items: WebAppComponentReleaseChannelBuildConfig[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponentRevision = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    branch: string;
    component_id: string;
    container_image_tag_id: string;
    container_image_tag_snapshot: {
      container_repository_id: string;
      name: string;
    };
    container_repository_snapshot: {
      domain: string;
      git_repository_id: string;
      id: string;
      name: string;
      root_directory: string;
      type: 'EcrLocal';
    };
    deployment_ref: {
      api_version: string;
      block_owner_deletion?: (boolean | null) | undefined;
      controller?: (boolean | null) | undefined;
      kind: string;
      name: string;
      uid: string;
    };
    deployment_strategy: string;
    project_id: string;
    release_channel_id: string;
    revision?: (number | null) | undefined;
    runtime_environment_variables_id: string;
  };
  status?:
    | ({
        conditions?: (any[] | null) | undefined;
        created_at?: (string | null) | undefined;
        finished_at?: (string | null) | undefined;
        is_success?: (boolean | null) | undefined;
        knative_revision_name?: (string | null) | undefined;
        knative_service_name?: (string | null) | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1WebAppComponentRevisionList = {
  apiVersion?: string | undefined;
  items: WebAppComponentRevision[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponent = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    default_build_config: {
      branch: string;
      root_directory: string;
    };
    domains: {
      domain_id: string;
      release_channel_id: string;
      subdomain: string;
    }[];
    git_repository_id: string;
    name: string;
    project_id: string;
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1WebAppComponentList = {
  apiVersion?: string | undefined;
  items: WebAppComponent[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};

`;

exports[`CLI options testing paths are relative to configfile, not to cwd 1`] = `
import { apiClient } from '../fixtures/emptyApi';
export const listAppthrustDevV1AlbGatewayParametersForAllNamespaces = (
  args: ListAppthrustDevV1AlbGatewayParametersForAllNamespacesApiArg
): Promise<ListAppthrustDevV1AlbGatewayParametersForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/albgatewayparameterses\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1AwsRoute53ZoneForAllNamespaces = (
  args: ListAppthrustDevV1AwsRoute53ZoneForAllNamespacesApiArg
): Promise<ListAppthrustDevV1AwsRoute53ZoneForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/awsroute53zones\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1CertForAllNamespaces = (
  args: ListAppthrustDevV1CertForAllNamespacesApiArg
): Promise<ListAppthrustDevV1CertForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/certs\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1ContainerImageTagForAllNamespaces = (
  args: ListAppthrustDevV1ContainerImageTagForAllNamespacesApiArg
): Promise<ListAppthrustDevV1ContainerImageTagForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/containerimagetags\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1ContainerRepositoryForAllNamespaces = (
  args: ListAppthrustDevV1ContainerRepositoryForAllNamespacesApiArg
): Promise<ListAppthrustDevV1ContainerRepositoryForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/containerrepositories\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1DnsZoneForAllNamespaces = (
  args: ListAppthrustDevV1DnsZoneForAllNamespacesApiArg
): Promise<ListAppthrustDevV1DnsZoneForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/dnszones\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1DnsZoneTransferForAllNamespaces = (
  args: ListAppthrustDevV1DnsZoneTransferForAllNamespacesApiArg
): Promise<ListAppthrustDevV1DnsZoneTransferForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/dnszonetransfers\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1DomainForAllNamespaces = (
  args: ListAppthrustDevV1DomainForAllNamespacesApiArg
): Promise<ListAppthrustDevV1DomainForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/domains\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1EksForAllNamespaces = (
  args: ListAppthrustDevV1EksForAllNamespacesApiArg
): Promise<ListAppthrustDevV1EksForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/eks\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1HttprouteToIngressForAllNamespaces = (
  args: ListAppthrustDevV1HttprouteToIngressForAllNamespacesApiArg
): Promise<ListAppthrustDevV1HttprouteToIngressForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/httproutetoingresses\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1IamDataForAllNamespaces = (
  args: ListAppthrustDevV1IamDataForAllNamespacesApiArg
): Promise<ListAppthrustDevV1IamDataForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/iamdatas\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1IamForAllNamespaces = (
  args: ListAppthrustDevV1IamForAllNamespacesApiArg
): Promise<ListAppthrustDevV1IamForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/iams\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1KeycloakClientSecretForAllNamespaces = (
  args: ListAppthrustDevV1KeycloakClientSecretForAllNamespacesApiArg
): Promise<ListAppthrustDevV1KeycloakClientSecretForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/keycloakclientsecrets\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1KeycloakKeyIdForAllNamespaces = (
  args: ListAppthrustDevV1KeycloakKeyIdForAllNamespacesApiArg
): Promise<ListAppthrustDevV1KeycloakKeyIdForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/keycloakkeyids\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1KeycloakPasswordInitForAllNamespaces = (
  args: ListAppthrustDevV1KeycloakPasswordInitForAllNamespacesApiArg
): Promise<ListAppthrustDevV1KeycloakPasswordInitForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/keycloakpasswordinits\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1NamespacedAlbGatewayParameters = (
  args: ListAppthrustDevV1NamespacedAlbGatewayParametersApiArg
): Promise<ListAppthrustDevV1NamespacedAlbGatewayParametersApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedAlbGatewayParameters = (
  args: CreateAppthrustDevV1NamespacedAlbGatewayParametersApiArg
): Promise<CreateAppthrustDevV1NamespacedAlbGatewayParametersApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses\`,
    method: 'POST',
    body: args.devAppthrustV1AlbGatewayParameters,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedAlbGatewayParameters = (
  args: DeleteAppthrustDevV1CollectionNamespacedAlbGatewayParametersApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedAlbGatewayParametersApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedAlbGatewayParameters = (
  args: ReadAppthrustDevV1NamespacedAlbGatewayParametersApiArg
): Promise<ReadAppthrustDevV1NamespacedAlbGatewayParametersApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedAlbGatewayParameters = (
  args: ReplaceAppthrustDevV1NamespacedAlbGatewayParametersApiArg
): Promise<ReplaceAppthrustDevV1NamespacedAlbGatewayParametersApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1AlbGatewayParameters,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedAlbGatewayParameters = (
  args: DeleteAppthrustDevV1NamespacedAlbGatewayParametersApiArg
): Promise<DeleteAppthrustDevV1NamespacedAlbGatewayParametersApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedAlbGatewayParameters = (
  args: PatchAppthrustDevV1NamespacedAlbGatewayParametersApiArg
): Promise<PatchAppthrustDevV1NamespacedAlbGatewayParametersApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedAlbGatewayParametersStatus = (
  args: ReadAppthrustDevV1NamespacedAlbGatewayParametersStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedAlbGatewayParametersStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedAlbGatewayParametersStatus = (
  args: ReplaceAppthrustDevV1NamespacedAlbGatewayParametersStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedAlbGatewayParametersStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1AlbGatewayParameters,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedAlbGatewayParametersStatus = (
  args: PatchAppthrustDevV1NamespacedAlbGatewayParametersStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedAlbGatewayParametersStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/albgatewayparameterses/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedAwsRoute53Zone = (
  args: ListAppthrustDevV1NamespacedAwsRoute53ZoneApiArg
): Promise<ListAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedAwsRoute53Zone = (
  args: CreateAppthrustDevV1NamespacedAwsRoute53ZoneApiArg
): Promise<CreateAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones\`,
    method: 'POST',
    body: args.devAppthrustV1AwsRoute53Zone,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedAwsRoute53Zone = (
  args: DeleteAppthrustDevV1CollectionNamespacedAwsRoute53ZoneApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedAwsRoute53ZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedAwsRoute53Zone = (
  args: ReadAppthrustDevV1NamespacedAwsRoute53ZoneApiArg
): Promise<ReadAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedAwsRoute53Zone = (
  args: ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneApiArg
): Promise<ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1AwsRoute53Zone,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedAwsRoute53Zone = (
  args: DeleteAppthrustDevV1NamespacedAwsRoute53ZoneApiArg
): Promise<DeleteAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedAwsRoute53Zone = (
  args: PatchAppthrustDevV1NamespacedAwsRoute53ZoneApiArg
): Promise<PatchAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedAwsRoute53ZoneStatus = (
  args: ReadAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedAwsRoute53ZoneStatus = (
  args: ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1AwsRoute53Zone,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedAwsRoute53ZoneStatus = (
  args: PatchAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/awsroute53zones/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedCert = (
  args: ListAppthrustDevV1NamespacedCertApiArg
): Promise<ListAppthrustDevV1NamespacedCertApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedCert = (
  args: CreateAppthrustDevV1NamespacedCertApiArg
): Promise<CreateAppthrustDevV1NamespacedCertApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs\`,
    method: 'POST',
    body: args.devAppthrustV1Cert,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedCert = (
  args: DeleteAppthrustDevV1CollectionNamespacedCertApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedCertApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedCert = (
  args: ReadAppthrustDevV1NamespacedCertApiArg
): Promise<ReadAppthrustDevV1NamespacedCertApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedCert = (
  args: ReplaceAppthrustDevV1NamespacedCertApiArg
): Promise<ReplaceAppthrustDevV1NamespacedCertApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1Cert,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedCert = (
  args: DeleteAppthrustDevV1NamespacedCertApiArg
): Promise<DeleteAppthrustDevV1NamespacedCertApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedCert = (
  args: PatchAppthrustDevV1NamespacedCertApiArg
): Promise<PatchAppthrustDevV1NamespacedCertApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedCertStatus = (
  args: ReadAppthrustDevV1NamespacedCertStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedCertStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedCertStatus = (
  args: ReplaceAppthrustDevV1NamespacedCertStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedCertStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1Cert,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedCertStatus = (
  args: PatchAppthrustDevV1NamespacedCertStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedCertStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/certs/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedContainerImageTag = (
  args: ListAppthrustDevV1NamespacedContainerImageTagApiArg
): Promise<ListAppthrustDevV1NamespacedContainerImageTagApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedContainerImageTag = (
  args: CreateAppthrustDevV1NamespacedContainerImageTagApiArg
): Promise<CreateAppthrustDevV1NamespacedContainerImageTagApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags\`,
    method: 'POST',
    body: args.devAppthrustV1ContainerImageTag,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedContainerImageTag = (
  args: DeleteAppthrustDevV1CollectionNamespacedContainerImageTagApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedContainerImageTagApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedContainerImageTag = (
  args: ReadAppthrustDevV1NamespacedContainerImageTagApiArg
): Promise<ReadAppthrustDevV1NamespacedContainerImageTagApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedContainerImageTag = (
  args: ReplaceAppthrustDevV1NamespacedContainerImageTagApiArg
): Promise<ReplaceAppthrustDevV1NamespacedContainerImageTagApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1ContainerImageTag,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedContainerImageTag = (
  args: DeleteAppthrustDevV1NamespacedContainerImageTagApiArg
): Promise<DeleteAppthrustDevV1NamespacedContainerImageTagApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedContainerImageTag = (
  args: PatchAppthrustDevV1NamespacedContainerImageTagApiArg
): Promise<PatchAppthrustDevV1NamespacedContainerImageTagApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedContainerImageTagStatus = (
  args: ReadAppthrustDevV1NamespacedContainerImageTagStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedContainerImageTagStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedContainerImageTagStatus = (
  args: ReplaceAppthrustDevV1NamespacedContainerImageTagStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedContainerImageTagStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1ContainerImageTag,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedContainerImageTagStatus = (
  args: PatchAppthrustDevV1NamespacedContainerImageTagStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedContainerImageTagStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerimagetags/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedContainerRepository = (
  args: ListAppthrustDevV1NamespacedContainerRepositoryApiArg
): Promise<ListAppthrustDevV1NamespacedContainerRepositoryApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedContainerRepository = (
  args: CreateAppthrustDevV1NamespacedContainerRepositoryApiArg
): Promise<CreateAppthrustDevV1NamespacedContainerRepositoryApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories\`,
    method: 'POST',
    body: args.devAppthrustV1ContainerRepository,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedContainerRepository = (
  args: DeleteAppthrustDevV1CollectionNamespacedContainerRepositoryApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedContainerRepositoryApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedContainerRepository = (
  args: ReadAppthrustDevV1NamespacedContainerRepositoryApiArg
): Promise<ReadAppthrustDevV1NamespacedContainerRepositoryApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedContainerRepository = (
  args: ReplaceAppthrustDevV1NamespacedContainerRepositoryApiArg
): Promise<ReplaceAppthrustDevV1NamespacedContainerRepositoryApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1ContainerRepository,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedContainerRepository = (
  args: DeleteAppthrustDevV1NamespacedContainerRepositoryApiArg
): Promise<DeleteAppthrustDevV1NamespacedContainerRepositoryApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedContainerRepository = (
  args: PatchAppthrustDevV1NamespacedContainerRepositoryApiArg
): Promise<PatchAppthrustDevV1NamespacedContainerRepositoryApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedContainerRepositoryStatus = (
  args: ReadAppthrustDevV1NamespacedContainerRepositoryStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedContainerRepositoryStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedContainerRepositoryStatus = (
  args: ReplaceAppthrustDevV1NamespacedContainerRepositoryStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedContainerRepositoryStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1ContainerRepository,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedContainerRepositoryStatus = (
  args: PatchAppthrustDevV1NamespacedContainerRepositoryStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedContainerRepositoryStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/containerrepositories/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedDnsZone = (
  args: ListAppthrustDevV1NamespacedDnsZoneApiArg
): Promise<ListAppthrustDevV1NamespacedDnsZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedDnsZone = (
  args: CreateAppthrustDevV1NamespacedDnsZoneApiArg
): Promise<CreateAppthrustDevV1NamespacedDnsZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones\`,
    method: 'POST',
    body: args.devAppthrustV1DnsZone,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedDnsZone = (
  args: DeleteAppthrustDevV1CollectionNamespacedDnsZoneApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedDnsZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedDnsZone = (
  args: ReadAppthrustDevV1NamespacedDnsZoneApiArg
): Promise<ReadAppthrustDevV1NamespacedDnsZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedDnsZone = (
  args: ReplaceAppthrustDevV1NamespacedDnsZoneApiArg
): Promise<ReplaceAppthrustDevV1NamespacedDnsZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1DnsZone,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedDnsZone = (
  args: DeleteAppthrustDevV1NamespacedDnsZoneApiArg
): Promise<DeleteAppthrustDevV1NamespacedDnsZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedDnsZone = (
  args: PatchAppthrustDevV1NamespacedDnsZoneApiArg
): Promise<PatchAppthrustDevV1NamespacedDnsZoneApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedDnsZoneStatus = (
  args: ReadAppthrustDevV1NamespacedDnsZoneStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedDnsZoneStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedDnsZoneStatus = (
  args: ReplaceAppthrustDevV1NamespacedDnsZoneStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedDnsZoneStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1DnsZone,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedDnsZoneStatus = (
  args: PatchAppthrustDevV1NamespacedDnsZoneStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedDnsZoneStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszones/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedDnsZoneTransfer = (
  args: ListAppthrustDevV1NamespacedDnsZoneTransferApiArg
): Promise<ListAppthrustDevV1NamespacedDnsZoneTransferApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedDnsZoneTransfer = (
  args: CreateAppthrustDevV1NamespacedDnsZoneTransferApiArg
): Promise<CreateAppthrustDevV1NamespacedDnsZoneTransferApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers\`,
    method: 'POST',
    body: args.devAppthrustV1DnsZoneTransfer,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedDnsZoneTransfer = (
  args: DeleteAppthrustDevV1CollectionNamespacedDnsZoneTransferApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedDnsZoneTransferApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedDnsZoneTransfer = (
  args: ReadAppthrustDevV1NamespacedDnsZoneTransferApiArg
): Promise<ReadAppthrustDevV1NamespacedDnsZoneTransferApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedDnsZoneTransfer = (
  args: ReplaceAppthrustDevV1NamespacedDnsZoneTransferApiArg
): Promise<ReplaceAppthrustDevV1NamespacedDnsZoneTransferApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1DnsZoneTransfer,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedDnsZoneTransfer = (
  args: DeleteAppthrustDevV1NamespacedDnsZoneTransferApiArg
): Promise<DeleteAppthrustDevV1NamespacedDnsZoneTransferApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedDnsZoneTransfer = (
  args: PatchAppthrustDevV1NamespacedDnsZoneTransferApiArg
): Promise<PatchAppthrustDevV1NamespacedDnsZoneTransferApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedDnsZoneTransferStatus = (
  args: ReadAppthrustDevV1NamespacedDnsZoneTransferStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedDnsZoneTransferStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedDnsZoneTransferStatus = (
  args: ReplaceAppthrustDevV1NamespacedDnsZoneTransferStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedDnsZoneTransferStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1DnsZoneTransfer,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedDnsZoneTransferStatus = (
  args: PatchAppthrustDevV1NamespacedDnsZoneTransferStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedDnsZoneTransferStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/dnszonetransfers/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedDomain = (
  args: ListAppthrustDevV1NamespacedDomainApiArg
): Promise<ListAppthrustDevV1NamespacedDomainApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedDomain = (
  args: CreateAppthrustDevV1NamespacedDomainApiArg
): Promise<CreateAppthrustDevV1NamespacedDomainApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains\`,
    method: 'POST',
    body: args.devAppthrustV1Domain,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedDomain = (
  args: DeleteAppthrustDevV1CollectionNamespacedDomainApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedDomainApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedDomain = (
  args: ReadAppthrustDevV1NamespacedDomainApiArg
): Promise<ReadAppthrustDevV1NamespacedDomainApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedDomain = (
  args: ReplaceAppthrustDevV1NamespacedDomainApiArg
): Promise<ReplaceAppthrustDevV1NamespacedDomainApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1Domain,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedDomain = (
  args: DeleteAppthrustDevV1NamespacedDomainApiArg
): Promise<DeleteAppthrustDevV1NamespacedDomainApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedDomain = (
  args: PatchAppthrustDevV1NamespacedDomainApiArg
): Promise<PatchAppthrustDevV1NamespacedDomainApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedDomainStatus = (
  args: ReadAppthrustDevV1NamespacedDomainStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedDomainStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedDomainStatus = (
  args: ReplaceAppthrustDevV1NamespacedDomainStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedDomainStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1Domain,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedDomainStatus = (
  args: PatchAppthrustDevV1NamespacedDomainStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedDomainStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/domains/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedEks = (
  args: ListAppthrustDevV1NamespacedEksApiArg
): Promise<ListAppthrustDevV1NamespacedEksApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedEks = (
  args: CreateAppthrustDevV1NamespacedEksApiArg
): Promise<CreateAppthrustDevV1NamespacedEksApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks\`,
    method: 'POST',
    body: args.devAppthrustV1Eks,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedEks = (
  args: DeleteAppthrustDevV1CollectionNamespacedEksApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedEksApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedEks = (
  args: ReadAppthrustDevV1NamespacedEksApiArg
): Promise<ReadAppthrustDevV1NamespacedEksApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedEks = (
  args: ReplaceAppthrustDevV1NamespacedEksApiArg
): Promise<ReplaceAppthrustDevV1NamespacedEksApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1Eks,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedEks = (
  args: DeleteAppthrustDevV1NamespacedEksApiArg
): Promise<DeleteAppthrustDevV1NamespacedEksApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedEks = (
  args: PatchAppthrustDevV1NamespacedEksApiArg
): Promise<PatchAppthrustDevV1NamespacedEksApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedEksStatus = (
  args: ReadAppthrustDevV1NamespacedEksStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedEksStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedEksStatus = (
  args: ReplaceAppthrustDevV1NamespacedEksStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedEksStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1Eks,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedEksStatus = (
  args: PatchAppthrustDevV1NamespacedEksStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedEksStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/eks/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedHttprouteToIngress = (
  args: ListAppthrustDevV1NamespacedHttprouteToIngressApiArg
): Promise<ListAppthrustDevV1NamespacedHttprouteToIngressApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedHttprouteToIngress = (
  args: CreateAppthrustDevV1NamespacedHttprouteToIngressApiArg
): Promise<CreateAppthrustDevV1NamespacedHttprouteToIngressApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses\`,
    method: 'POST',
    body: args.devAppthrustV1HttprouteToIngress,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedHttprouteToIngress = (
  args: DeleteAppthrustDevV1CollectionNamespacedHttprouteToIngressApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedHttprouteToIngressApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedHttprouteToIngress = (
  args: ReadAppthrustDevV1NamespacedHttprouteToIngressApiArg
): Promise<ReadAppthrustDevV1NamespacedHttprouteToIngressApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedHttprouteToIngress = (
  args: ReplaceAppthrustDevV1NamespacedHttprouteToIngressApiArg
): Promise<ReplaceAppthrustDevV1NamespacedHttprouteToIngressApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1HttprouteToIngress,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedHttprouteToIngress = (
  args: DeleteAppthrustDevV1NamespacedHttprouteToIngressApiArg
): Promise<DeleteAppthrustDevV1NamespacedHttprouteToIngressApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedHttprouteToIngress = (
  args: PatchAppthrustDevV1NamespacedHttprouteToIngressApiArg
): Promise<PatchAppthrustDevV1NamespacedHttprouteToIngressApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedHttprouteToIngressStatus = (
  args: ReadAppthrustDevV1NamespacedHttprouteToIngressStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedHttprouteToIngressStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedHttprouteToIngressStatus = (
  args: ReplaceAppthrustDevV1NamespacedHttprouteToIngressStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedHttprouteToIngressStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1HttprouteToIngress,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedHttprouteToIngressStatus = (
  args: PatchAppthrustDevV1NamespacedHttprouteToIngressStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedHttprouteToIngressStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/httproutetoingresses/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedIamData = (
  args: ListAppthrustDevV1NamespacedIamDataApiArg
): Promise<ListAppthrustDevV1NamespacedIamDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedIamData = (
  args: CreateAppthrustDevV1NamespacedIamDataApiArg
): Promise<CreateAppthrustDevV1NamespacedIamDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas\`,
    method: 'POST',
    body: args.devAppthrustV1IamData,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedIamData = (
  args: DeleteAppthrustDevV1CollectionNamespacedIamDataApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedIamDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedIamData = (
  args: ReadAppthrustDevV1NamespacedIamDataApiArg
): Promise<ReadAppthrustDevV1NamespacedIamDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedIamData = (
  args: ReplaceAppthrustDevV1NamespacedIamDataApiArg
): Promise<ReplaceAppthrustDevV1NamespacedIamDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1IamData,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedIamData = (
  args: DeleteAppthrustDevV1NamespacedIamDataApiArg
): Promise<DeleteAppthrustDevV1NamespacedIamDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedIamData = (
  args: PatchAppthrustDevV1NamespacedIamDataApiArg
): Promise<PatchAppthrustDevV1NamespacedIamDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedIamDataStatus = (
  args: ReadAppthrustDevV1NamespacedIamDataStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedIamDataStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedIamDataStatus = (
  args: ReplaceAppthrustDevV1NamespacedIamDataStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedIamDataStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1IamData,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedIamDataStatus = (
  args: PatchAppthrustDevV1NamespacedIamDataStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedIamDataStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iamdatas/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedIam = (
  args: ListAppthrustDevV1NamespacedIamApiArg
): Promise<ListAppthrustDevV1NamespacedIamApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedIam = (
  args: CreateAppthrustDevV1NamespacedIamApiArg
): Promise<CreateAppthrustDevV1NamespacedIamApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams\`,
    method: 'POST',
    body: args.devAppthrustV1Iam,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedIam = (
  args: DeleteAppthrustDevV1CollectionNamespacedIamApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedIamApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedIam = (
  args: ReadAppthrustDevV1NamespacedIamApiArg
): Promise<ReadAppthrustDevV1NamespacedIamApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedIam = (
  args: ReplaceAppthrustDevV1NamespacedIamApiArg
): Promise<ReplaceAppthrustDevV1NamespacedIamApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1Iam,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedIam = (
  args: DeleteAppthrustDevV1NamespacedIamApiArg
): Promise<DeleteAppthrustDevV1NamespacedIamApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedIam = (
  args: PatchAppthrustDevV1NamespacedIamApiArg
): Promise<PatchAppthrustDevV1NamespacedIamApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedIamStatus = (
  args: ReadAppthrustDevV1NamespacedIamStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedIamStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedIamStatus = (
  args: ReplaceAppthrustDevV1NamespacedIamStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedIamStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1Iam,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedIamStatus = (
  args: PatchAppthrustDevV1NamespacedIamStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedIamStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/iams/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedKeycloakClientSecret = (
  args: ListAppthrustDevV1NamespacedKeycloakClientSecretApiArg
): Promise<ListAppthrustDevV1NamespacedKeycloakClientSecretApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedKeycloakClientSecret = (
  args: CreateAppthrustDevV1NamespacedKeycloakClientSecretApiArg
): Promise<CreateAppthrustDevV1NamespacedKeycloakClientSecretApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets\`,
    method: 'POST',
    body: args.devAppthrustV1KeycloakClientSecret,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedKeycloakClientSecret = (
  args: DeleteAppthrustDevV1CollectionNamespacedKeycloakClientSecretApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedKeycloakClientSecretApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedKeycloakClientSecret = (
  args: ReadAppthrustDevV1NamespacedKeycloakClientSecretApiArg
): Promise<ReadAppthrustDevV1NamespacedKeycloakClientSecretApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedKeycloakClientSecret = (
  args: ReplaceAppthrustDevV1NamespacedKeycloakClientSecretApiArg
): Promise<ReplaceAppthrustDevV1NamespacedKeycloakClientSecretApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1KeycloakClientSecret,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedKeycloakClientSecret = (
  args: DeleteAppthrustDevV1NamespacedKeycloakClientSecretApiArg
): Promise<DeleteAppthrustDevV1NamespacedKeycloakClientSecretApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedKeycloakClientSecret = (
  args: PatchAppthrustDevV1NamespacedKeycloakClientSecretApiArg
): Promise<PatchAppthrustDevV1NamespacedKeycloakClientSecretApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedKeycloakClientSecretStatus = (
  args: ReadAppthrustDevV1NamespacedKeycloakClientSecretStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedKeycloakClientSecretStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedKeycloakClientSecretStatus = (
  args: ReplaceAppthrustDevV1NamespacedKeycloakClientSecretStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedKeycloakClientSecretStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1KeycloakClientSecret,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedKeycloakClientSecretStatus = (
  args: PatchAppthrustDevV1NamespacedKeycloakClientSecretStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedKeycloakClientSecretStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakclientsecrets/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedKeycloakKeyId = (
  args: ListAppthrustDevV1NamespacedKeycloakKeyIdApiArg
): Promise<ListAppthrustDevV1NamespacedKeycloakKeyIdApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedKeycloakKeyId = (
  args: CreateAppthrustDevV1NamespacedKeycloakKeyIdApiArg
): Promise<CreateAppthrustDevV1NamespacedKeycloakKeyIdApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids\`,
    method: 'POST',
    body: args.devAppthrustV1KeycloakKeyId,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedKeycloakKeyId = (
  args: DeleteAppthrustDevV1CollectionNamespacedKeycloakKeyIdApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedKeycloakKeyIdApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedKeycloakKeyId = (
  args: ReadAppthrustDevV1NamespacedKeycloakKeyIdApiArg
): Promise<ReadAppthrustDevV1NamespacedKeycloakKeyIdApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedKeycloakKeyId = (
  args: ReplaceAppthrustDevV1NamespacedKeycloakKeyIdApiArg
): Promise<ReplaceAppthrustDevV1NamespacedKeycloakKeyIdApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1KeycloakKeyId,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedKeycloakKeyId = (
  args: DeleteAppthrustDevV1NamespacedKeycloakKeyIdApiArg
): Promise<DeleteAppthrustDevV1NamespacedKeycloakKeyIdApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedKeycloakKeyId = (
  args: PatchAppthrustDevV1NamespacedKeycloakKeyIdApiArg
): Promise<PatchAppthrustDevV1NamespacedKeycloakKeyIdApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedKeycloakKeyIdStatus = (
  args: ReadAppthrustDevV1NamespacedKeycloakKeyIdStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedKeycloakKeyIdStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedKeycloakKeyIdStatus = (
  args: ReplaceAppthrustDevV1NamespacedKeycloakKeyIdStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedKeycloakKeyIdStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1KeycloakKeyId,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedKeycloakKeyIdStatus = (
  args: PatchAppthrustDevV1NamespacedKeycloakKeyIdStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedKeycloakKeyIdStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakkeyids/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedKeycloakPasswordInit = (
  args: ListAppthrustDevV1NamespacedKeycloakPasswordInitApiArg
): Promise<ListAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedKeycloakPasswordInit = (
  args: CreateAppthrustDevV1NamespacedKeycloakPasswordInitApiArg
): Promise<CreateAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits\`,
    method: 'POST',
    body: args.devAppthrustV1KeycloakPasswordInit,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedKeycloakPasswordInit = (
  args: DeleteAppthrustDevV1CollectionNamespacedKeycloakPasswordInitApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedKeycloakPasswordInitApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedKeycloakPasswordInit = (
  args: ReadAppthrustDevV1NamespacedKeycloakPasswordInitApiArg
): Promise<ReadAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedKeycloakPasswordInit = (
  args: ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitApiArg
): Promise<ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1KeycloakPasswordInit,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedKeycloakPasswordInit = (
  args: DeleteAppthrustDevV1NamespacedKeycloakPasswordInitApiArg
): Promise<DeleteAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedKeycloakPasswordInit = (
  args: PatchAppthrustDevV1NamespacedKeycloakPasswordInitApiArg
): Promise<PatchAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedKeycloakPasswordInitStatus = (
  args: ReadAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedKeycloakPasswordInitStatus = (
  args: ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1KeycloakPasswordInit,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedKeycloakPasswordInitStatus = (
  args: PatchAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/keycloakpasswordinits/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedNextAuthSecretRequest = (
  args: ListAppthrustDevV1NamespacedNextAuthSecretRequestApiArg
): Promise<ListAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedNextAuthSecretRequest = (
  args: CreateAppthrustDevV1NamespacedNextAuthSecretRequestApiArg
): Promise<CreateAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests\`,
    method: 'POST',
    body: args.devAppthrustV1NextAuthSecretRequest,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedNextAuthSecretRequest = (
  args: DeleteAppthrustDevV1CollectionNamespacedNextAuthSecretRequestApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedNextAuthSecretRequestApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedNextAuthSecretRequest = (
  args: ReadAppthrustDevV1NamespacedNextAuthSecretRequestApiArg
): Promise<ReadAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedNextAuthSecretRequest = (
  args: ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestApiArg
): Promise<ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1NextAuthSecretRequest,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedNextAuthSecretRequest = (
  args: DeleteAppthrustDevV1NamespacedNextAuthSecretRequestApiArg
): Promise<DeleteAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedNextAuthSecretRequest = (
  args: PatchAppthrustDevV1NamespacedNextAuthSecretRequestApiArg
): Promise<PatchAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedNextAuthSecretRequestStatus = (
  args: ReadAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedNextAuthSecretRequestStatus = (
  args: ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1NextAuthSecretRequest,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedNextAuthSecretRequestStatus = (
  args: PatchAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/nextauthsecretrequests/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedProject = (
  args: ListAppthrustDevV1NamespacedProjectApiArg
): Promise<ListAppthrustDevV1NamespacedProjectApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedProject = (
  args: CreateAppthrustDevV1NamespacedProjectApiArg
): Promise<CreateAppthrustDevV1NamespacedProjectApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects\`,
    method: 'POST',
    body: args.devAppthrustV1Project,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedProject = (
  args: DeleteAppthrustDevV1CollectionNamespacedProjectApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedProjectApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedProject = (
  args: ReadAppthrustDevV1NamespacedProjectApiArg
): Promise<ReadAppthrustDevV1NamespacedProjectApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedProject = (
  args: ReplaceAppthrustDevV1NamespacedProjectApiArg
): Promise<ReplaceAppthrustDevV1NamespacedProjectApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1Project,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedProject = (
  args: DeleteAppthrustDevV1NamespacedProjectApiArg
): Promise<DeleteAppthrustDevV1NamespacedProjectApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedProject = (
  args: PatchAppthrustDevV1NamespacedProjectApiArg
): Promise<PatchAppthrustDevV1NamespacedProjectApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedProjectStatus = (
  args: ReadAppthrustDevV1NamespacedProjectStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedProjectStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedProjectStatus = (
  args: ReplaceAppthrustDevV1NamespacedProjectStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedProjectStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1Project,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedProjectStatus = (
  args: PatchAppthrustDevV1NamespacedProjectStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedProjectStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/projects/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedReleaseChannel = (
  args: ListAppthrustDevV1NamespacedReleaseChannelApiArg
): Promise<ListAppthrustDevV1NamespacedReleaseChannelApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedReleaseChannel = (
  args: CreateAppthrustDevV1NamespacedReleaseChannelApiArg
): Promise<CreateAppthrustDevV1NamespacedReleaseChannelApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels\`,
    method: 'POST',
    body: args.devAppthrustV1ReleaseChannel,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedReleaseChannel = (
  args: DeleteAppthrustDevV1CollectionNamespacedReleaseChannelApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedReleaseChannelApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedReleaseChannel = (
  args: ReadAppthrustDevV1NamespacedReleaseChannelApiArg
): Promise<ReadAppthrustDevV1NamespacedReleaseChannelApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedReleaseChannel = (
  args: ReplaceAppthrustDevV1NamespacedReleaseChannelApiArg
): Promise<ReplaceAppthrustDevV1NamespacedReleaseChannelApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1ReleaseChannel,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedReleaseChannel = (
  args: DeleteAppthrustDevV1NamespacedReleaseChannelApiArg
): Promise<DeleteAppthrustDevV1NamespacedReleaseChannelApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedReleaseChannel = (
  args: PatchAppthrustDevV1NamespacedReleaseChannelApiArg
): Promise<PatchAppthrustDevV1NamespacedReleaseChannelApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedReleaseChannelStatus = (
  args: ReadAppthrustDevV1NamespacedReleaseChannelStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedReleaseChannelStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedReleaseChannelStatus = (
  args: ReplaceAppthrustDevV1NamespacedReleaseChannelStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedReleaseChannelStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1ReleaseChannel,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedReleaseChannelStatus = (
  args: PatchAppthrustDevV1NamespacedReleaseChannelStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedReleaseChannelStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/releasechannels/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedResourceValueSync = (
  args: ListAppthrustDevV1NamespacedResourceValueSyncApiArg
): Promise<ListAppthrustDevV1NamespacedResourceValueSyncApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedResourceValueSync = (
  args: CreateAppthrustDevV1NamespacedResourceValueSyncApiArg
): Promise<CreateAppthrustDevV1NamespacedResourceValueSyncApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs\`,
    method: 'POST',
    body: args.devAppthrustV1ResourceValueSync,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedResourceValueSync = (
  args: DeleteAppthrustDevV1CollectionNamespacedResourceValueSyncApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedResourceValueSyncApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedResourceValueSync = (
  args: ReadAppthrustDevV1NamespacedResourceValueSyncApiArg
): Promise<ReadAppthrustDevV1NamespacedResourceValueSyncApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedResourceValueSync = (
  args: ReplaceAppthrustDevV1NamespacedResourceValueSyncApiArg
): Promise<ReplaceAppthrustDevV1NamespacedResourceValueSyncApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1ResourceValueSync,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedResourceValueSync = (
  args: DeleteAppthrustDevV1NamespacedResourceValueSyncApiArg
): Promise<DeleteAppthrustDevV1NamespacedResourceValueSyncApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedResourceValueSync = (
  args: PatchAppthrustDevV1NamespacedResourceValueSyncApiArg
): Promise<PatchAppthrustDevV1NamespacedResourceValueSyncApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedResourceValueSyncStatus = (
  args: ReadAppthrustDevV1NamespacedResourceValueSyncStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedResourceValueSyncStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedResourceValueSyncStatus = (
  args: ReplaceAppthrustDevV1NamespacedResourceValueSyncStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedResourceValueSyncStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1ResourceValueSync,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedResourceValueSyncStatus = (
  args: PatchAppthrustDevV1NamespacedResourceValueSyncStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedResourceValueSyncStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/resourcevaluesyncs/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedTfApply = (
  args: ListAppthrustDevV1NamespacedTfApplyApiArg
): Promise<ListAppthrustDevV1NamespacedTfApplyApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedTfApply = (
  args: CreateAppthrustDevV1NamespacedTfApplyApiArg
): Promise<CreateAppthrustDevV1NamespacedTfApplyApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies\`,
    method: 'POST',
    body: args.devAppthrustV1TfApply,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedTfApply = (
  args: DeleteAppthrustDevV1CollectionNamespacedTfApplyApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedTfApplyApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedTfApply = (
  args: ReadAppthrustDevV1NamespacedTfApplyApiArg
): Promise<ReadAppthrustDevV1NamespacedTfApplyApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedTfApply = (
  args: ReplaceAppthrustDevV1NamespacedTfApplyApiArg
): Promise<ReplaceAppthrustDevV1NamespacedTfApplyApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1TfApply,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedTfApply = (
  args: DeleteAppthrustDevV1NamespacedTfApplyApiArg
): Promise<DeleteAppthrustDevV1NamespacedTfApplyApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedTfApply = (
  args: PatchAppthrustDevV1NamespacedTfApplyApiArg
): Promise<PatchAppthrustDevV1NamespacedTfApplyApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedTfApplyStatus = (
  args: ReadAppthrustDevV1NamespacedTfApplyStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedTfApplyStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedTfApplyStatus = (
  args: ReplaceAppthrustDevV1NamespacedTfApplyStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedTfApplyStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1TfApply,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedTfApplyStatus = (
  args: PatchAppthrustDevV1NamespacedTfApplyStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedTfApplyStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/tfapplies/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedTrafficSplitting = (
  args: ListAppthrustDevV1NamespacedTrafficSplittingApiArg
): Promise<ListAppthrustDevV1NamespacedTrafficSplittingApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedTrafficSplitting = (
  args: CreateAppthrustDevV1NamespacedTrafficSplittingApiArg
): Promise<CreateAppthrustDevV1NamespacedTrafficSplittingApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings\`,
    method: 'POST',
    body: args.devAppthrustV1TrafficSplitting,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedTrafficSplitting = (
  args: DeleteAppthrustDevV1CollectionNamespacedTrafficSplittingApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedTrafficSplittingApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedTrafficSplitting = (
  args: ReadAppthrustDevV1NamespacedTrafficSplittingApiArg
): Promise<ReadAppthrustDevV1NamespacedTrafficSplittingApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedTrafficSplitting = (
  args: ReplaceAppthrustDevV1NamespacedTrafficSplittingApiArg
): Promise<ReplaceAppthrustDevV1NamespacedTrafficSplittingApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1TrafficSplitting,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedTrafficSplitting = (
  args: DeleteAppthrustDevV1NamespacedTrafficSplittingApiArg
): Promise<DeleteAppthrustDevV1NamespacedTrafficSplittingApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedTrafficSplitting = (
  args: PatchAppthrustDevV1NamespacedTrafficSplittingApiArg
): Promise<PatchAppthrustDevV1NamespacedTrafficSplittingApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedTrafficSplittingStatus = (
  args: ReadAppthrustDevV1NamespacedTrafficSplittingStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedTrafficSplittingStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedTrafficSplittingStatus = (
  args: ReplaceAppthrustDevV1NamespacedTrafficSplittingStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedTrafficSplittingStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1TrafficSplitting,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedTrafficSplittingStatus = (
  args: PatchAppthrustDevV1NamespacedTrafficSplittingStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedTrafficSplittingStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/trafficsplittings/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedVpcData = (
  args: ListAppthrustDevV1NamespacedVpcDataApiArg
): Promise<ListAppthrustDevV1NamespacedVpcDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedVpcData = (
  args: CreateAppthrustDevV1NamespacedVpcDataApiArg
): Promise<CreateAppthrustDevV1NamespacedVpcDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas\`,
    method: 'POST',
    body: args.devAppthrustV1VpcData,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedVpcData = (
  args: DeleteAppthrustDevV1CollectionNamespacedVpcDataApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedVpcDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedVpcData = (
  args: ReadAppthrustDevV1NamespacedVpcDataApiArg
): Promise<ReadAppthrustDevV1NamespacedVpcDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedVpcData = (
  args: ReplaceAppthrustDevV1NamespacedVpcDataApiArg
): Promise<ReplaceAppthrustDevV1NamespacedVpcDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1VpcData,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedVpcData = (
  args: DeleteAppthrustDevV1NamespacedVpcDataApiArg
): Promise<DeleteAppthrustDevV1NamespacedVpcDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedVpcData = (
  args: PatchAppthrustDevV1NamespacedVpcDataApiArg
): Promise<PatchAppthrustDevV1NamespacedVpcDataApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedVpcDataStatus = (
  args: ReadAppthrustDevV1NamespacedVpcDataStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedVpcDataStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedVpcDataStatus = (
  args: ReplaceAppthrustDevV1NamespacedVpcDataStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedVpcDataStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1VpcData,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedVpcDataStatus = (
  args: PatchAppthrustDevV1NamespacedVpcDataStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedVpcDataStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcdatas/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedVpc = (
  args: ListAppthrustDevV1NamespacedVpcApiArg
): Promise<ListAppthrustDevV1NamespacedVpcApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedVpc = (
  args: CreateAppthrustDevV1NamespacedVpcApiArg
): Promise<CreateAppthrustDevV1NamespacedVpcApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs\`,
    method: 'POST',
    body: args.devAppthrustV1Vpc,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedVpc = (
  args: DeleteAppthrustDevV1CollectionNamespacedVpcApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedVpcApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedVpc = (
  args: ReadAppthrustDevV1NamespacedVpcApiArg
): Promise<ReadAppthrustDevV1NamespacedVpcApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedVpc = (
  args: ReplaceAppthrustDevV1NamespacedVpcApiArg
): Promise<ReplaceAppthrustDevV1NamespacedVpcApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1Vpc,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedVpc = (
  args: DeleteAppthrustDevV1NamespacedVpcApiArg
): Promise<DeleteAppthrustDevV1NamespacedVpcApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedVpc = (
  args: PatchAppthrustDevV1NamespacedVpcApiArg
): Promise<PatchAppthrustDevV1NamespacedVpcApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedVpcStatus = (
  args: ReadAppthrustDevV1NamespacedVpcStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedVpcStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedVpcStatus = (
  args: ReplaceAppthrustDevV1NamespacedVpcStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedVpcStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1Vpc,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedVpcStatus = (
  args: PatchAppthrustDevV1NamespacedVpcStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedVpcStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/vpcs/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWaf = (
  args: ListAppthrustDevV1NamespacedWafApiArg
): Promise<ListAppthrustDevV1NamespacedWafApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWaf = (
  args: CreateAppthrustDevV1NamespacedWafApiArg
): Promise<CreateAppthrustDevV1NamespacedWafApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs\`,
    method: 'POST',
    body: args.devAppthrustV1Waf,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWaf = (
  args: DeleteAppthrustDevV1CollectionNamespacedWafApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWafApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWaf = (
  args: ReadAppthrustDevV1NamespacedWafApiArg
): Promise<ReadAppthrustDevV1NamespacedWafApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWaf = (
  args: ReplaceAppthrustDevV1NamespacedWafApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWafApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1Waf,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWaf = (
  args: DeleteAppthrustDevV1NamespacedWafApiArg
): Promise<DeleteAppthrustDevV1NamespacedWafApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWaf = (
  args: PatchAppthrustDevV1NamespacedWafApiArg
): Promise<PatchAppthrustDevV1NamespacedWafApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWafStatus = (
  args: ReadAppthrustDevV1NamespacedWafStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWafStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWafStatus = (
  args: ReplaceAppthrustDevV1NamespacedWafStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWafStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1Waf,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWafStatus = (
  args: PatchAppthrustDevV1NamespacedWafStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWafStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/wafs/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponentBuildFinished = (
  args: ListAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponentBuildFinished = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponentBuildFinished,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildFinished = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildFinishedApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildFinishedApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentBuildFinished = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentBuildFinished = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentBuildFinished,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponentBuildFinished = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentBuildFinished = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentBuildFinished,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuildfinisheds/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponentBuild = (
  args: ListAppthrustDevV1NamespacedWebAppComponentBuildApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentBuildApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponentBuild = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentBuildApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentBuildApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponentBuild,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponentBuild = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentBuild = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentBuildApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentBuildApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentBuild = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentBuildApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentBuildApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentBuild,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponentBuild = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentBuildApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentBuildApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentBuild = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentBuildApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentBuildApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentBuildStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentBuildStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentBuildStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentBuildStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentBuildStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentBuildStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentBuild,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentBuildStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentBuildStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentBuildStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentbuilds/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponentDeployment = (
  args: ListAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponentDeployment = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponentDeployment,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponentDeployment = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentDeploymentApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentDeploymentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentDeployment = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentDeployment = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentDeployment,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponentDeployment = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentDeployment = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentDeploymentStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentDeploymentStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentDeployment,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentDeploymentStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentdeployments/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponentGatewayConnection = (
  args: ListAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponentGatewayConnection = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponentGatewayConnection,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponentGatewayConnection = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentGatewayConnectionApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentGatewayConnectionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentGatewayConnection = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentGatewayConnection = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentGatewayConnection,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponentGatewayConnection = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentGatewayConnection = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentGatewayConnection,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentgatewayconnections/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponentPipeline = (
  args: ListAppthrustDevV1NamespacedWebAppComponentPipelineApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponentPipeline = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentPipelineApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponentPipeline,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponentPipeline = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentPipelineApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentPipelineApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentPipeline = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentPipelineApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentPipeline = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentPipeline,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponentPipeline = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentPipelineApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentPipeline = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentPipelineApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentPipelineStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentPipelineStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentPipeline,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentPipelineStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentpipelines/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfig = (
  args: ListAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfig = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponentReleaseChannelBuildConfig,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponentReleaseChannelBuildConfig = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentReleaseChannelBuildConfigApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentReleaseChannelBuildConfigApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfig = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfig = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentReleaseChannelBuildConfig,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfig = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfig = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentReleaseChannelBuildConfig,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentreleasechannelbuildconfigs/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponentRevision = (
  args: ListAppthrustDevV1NamespacedWebAppComponentRevisionApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponentRevision = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentRevisionApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponentRevision,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponentRevision = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentRevisionApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentRevisionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentRevision = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentRevisionApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentRevision = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentRevision,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponentRevision = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentRevisionApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentRevision = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentRevisionApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentRevisionStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentRevisionStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponentRevision,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentRevisionStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponentrevisions/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NamespacedWebAppComponent = (
  args: ListAppthrustDevV1NamespacedWebAppComponentApiArg
): Promise<ListAppthrustDevV1NamespacedWebAppComponentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents\`,
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const createAppthrustDevV1NamespacedWebAppComponent = (
  args: CreateAppthrustDevV1NamespacedWebAppComponentApiArg
): Promise<CreateAppthrustDevV1NamespacedWebAppComponentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents\`,
    method: 'POST',
    body: args.devAppthrustV1WebAppComponent,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1CollectionNamespacedWebAppComponent = (
  args: DeleteAppthrustDevV1CollectionNamespacedWebAppComponentApiArg
): Promise<DeleteAppthrustDevV1CollectionNamespacedWebAppComponentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents\`,
    method: 'DELETE',
    params: {
      pretty: args.pretty,
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponent = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents/\${args.name}\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponent = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents/\${args.name}\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponent,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const deleteAppthrustDevV1NamespacedWebAppComponent = (
  args: DeleteAppthrustDevV1NamespacedWebAppComponentApiArg
): Promise<DeleteAppthrustDevV1NamespacedWebAppComponentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents/\${args.name}\`,
    method: 'DELETE',
    body: args.ioK8SApimachineryPkgApisMetaV1DeleteOptions,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      gracePeriodSeconds: args.gracePeriodSeconds,
      orphanDependents: args.orphanDependents,
      propagationPolicy: args.propagationPolicy,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponent = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents/\${args.name}\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const readAppthrustDevV1NamespacedWebAppComponentStatus = (
  args: ReadAppthrustDevV1NamespacedWebAppComponentStatusApiArg
): Promise<ReadAppthrustDevV1NamespacedWebAppComponentStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents/\${args.name}/status\`,
    params: { pretty: args.pretty, resourceVersion: args.resourceVersion },
  });
};
export const replaceAppthrustDevV1NamespacedWebAppComponentStatus = (
  args: ReplaceAppthrustDevV1NamespacedWebAppComponentStatusApiArg
): Promise<ReplaceAppthrustDevV1NamespacedWebAppComponentStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents/\${args.name}/status\`,
    method: 'PUT',
    body: args.devAppthrustV1WebAppComponent,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
    },
  });
};
export const patchAppthrustDevV1NamespacedWebAppComponentStatus = (
  args: PatchAppthrustDevV1NamespacedWebAppComponentStatusApiArg
): Promise<PatchAppthrustDevV1NamespacedWebAppComponentStatusApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/namespaces/\${args['namespace']}/webappcomponents/\${args.name}/status\`,
    method: 'PATCH',
    body: args.body,
    params: {
      pretty: args.pretty,
      dryRun: args.dryRun,
      fieldManager: args.fieldManager,
      fieldValidation: args.fieldValidation,
      force: args.force,
    },
  });
};
export const listAppthrustDevV1NextAuthSecretRequestForAllNamespaces = (
  args: ListAppthrustDevV1NextAuthSecretRequestForAllNamespacesApiArg
): Promise<ListAppthrustDevV1NextAuthSecretRequestForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/nextauthsecretrequests\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1ProjectForAllNamespaces = (
  args: ListAppthrustDevV1ProjectForAllNamespacesApiArg
): Promise<ListAppthrustDevV1ProjectForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/projects\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1ReleaseChannelForAllNamespaces = (
  args: ListAppthrustDevV1ReleaseChannelForAllNamespacesApiArg
): Promise<ListAppthrustDevV1ReleaseChannelForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/releasechannels\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1ResourceValueSyncForAllNamespaces = (
  args: ListAppthrustDevV1ResourceValueSyncForAllNamespacesApiArg
): Promise<ListAppthrustDevV1ResourceValueSyncForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/resourcevaluesyncs\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1TfApplyForAllNamespaces = (
  args: ListAppthrustDevV1TfApplyForAllNamespacesApiArg
): Promise<ListAppthrustDevV1TfApplyForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/tfapplies\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1TrafficSplittingForAllNamespaces = (
  args: ListAppthrustDevV1TrafficSplittingForAllNamespacesApiArg
): Promise<ListAppthrustDevV1TrafficSplittingForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/trafficsplittings\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1VpcDataForAllNamespaces = (
  args: ListAppthrustDevV1VpcDataForAllNamespacesApiArg
): Promise<ListAppthrustDevV1VpcDataForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/vpcdatas\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1VpcForAllNamespaces = (
  args: ListAppthrustDevV1VpcForAllNamespacesApiArg
): Promise<ListAppthrustDevV1VpcForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/vpcs\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WafForAllNamespaces = (
  args: ListAppthrustDevV1WafForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WafForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/wafs\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentBuildFinishedForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentBuildFinishedForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentBuildFinishedForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponentbuildfinisheds\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentBuildForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentBuildForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentBuildForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponentbuilds\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentDeploymentForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentDeploymentForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentDeploymentForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponentdeployments\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentGatewayConnectionForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentGatewayConnectionForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentGatewayConnectionForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponentgatewayconnections\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentPipelineForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentPipelineForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentPipelineForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponentpipelines\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentReleaseChannelBuildConfigForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentReleaseChannelBuildConfigForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentReleaseChannelBuildConfigForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponentreleasechannelbuildconfigs\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentRevisionForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentRevisionForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentRevisionForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponentrevisions\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export const listAppthrustDevV1WebAppComponentForAllNamespaces = (
  args: ListAppthrustDevV1WebAppComponentForAllNamespacesApiArg
): Promise<ListAppthrustDevV1WebAppComponentForAllNamespacesApiResponse> => {
  return apiClient({
    path: \`/apis/appthrust.dev/v1/webappcomponents\`,
    params: {
      allowWatchBookmarks: args.allowWatchBookmarks,
      continue: args['continue'],
      fieldSelector: args.fieldSelector,
      labelSelector: args.labelSelector,
      limit: args.limit,
      pretty: args.pretty,
      resourceVersion: args.resourceVersion,
      resourceVersionMatch: args.resourceVersionMatch,
      sendInitialEvents: args.sendInitialEvents,
      timeoutSeconds: args.timeoutSeconds,
      watch: args.watch,
    },
  });
};
export type ListAppthrustDevV1AlbGatewayParametersForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1AlbGatewayParametersList;
export type ListAppthrustDevV1AlbGatewayParametersForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1AwsRoute53ZoneForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1AwsRoute53ZoneList;
export type ListAppthrustDevV1AwsRoute53ZoneForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1CertForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1CertList;
export type ListAppthrustDevV1CertForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1ContainerImageTagForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1ContainerImageTagList;
export type ListAppthrustDevV1ContainerImageTagForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1ContainerRepositoryForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1ContainerRepositoryList;
export type ListAppthrustDevV1ContainerRepositoryForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1DnsZoneForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1DnsZoneList;
export type ListAppthrustDevV1DnsZoneForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1DnsZoneTransferForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1DnsZoneTransferList;
export type ListAppthrustDevV1DnsZoneTransferForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1DomainForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1DomainList;
export type ListAppthrustDevV1DomainForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1EksForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1EksList;
export type ListAppthrustDevV1EksForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1HttprouteToIngressForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1HttprouteToIngressList;
export type ListAppthrustDevV1HttprouteToIngressForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1IamDataForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1IamDataList;
export type ListAppthrustDevV1IamDataForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1IamForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1IamList;
export type ListAppthrustDevV1IamForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1KeycloakClientSecretForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1KeycloakClientSecretList;
export type ListAppthrustDevV1KeycloakClientSecretForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1KeycloakKeyIdForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1KeycloakKeyIdList;
export type ListAppthrustDevV1KeycloakKeyIdForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1KeycloakPasswordInitForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1KeycloakPasswordInitList;
export type ListAppthrustDevV1KeycloakPasswordInitForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1NamespacedAlbGatewayParametersApiResponse =
  /** status 200 OK */ DevAppthrustV1AlbGatewayParametersList;
export type ListAppthrustDevV1NamespacedAlbGatewayParametersApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedAlbGatewayParametersApiResponse = /** status 200 OK */
  | AlbGatewayParameters
  | /** status 201 Created */ AlbGatewayParameters
  | /** status 202 Accepted */ AlbGatewayParameters;
export type CreateAppthrustDevV1NamespacedAlbGatewayParametersApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1AlbGatewayParameters: AlbGatewayParameters;
};
export type DeleteAppthrustDevV1CollectionNamespacedAlbGatewayParametersApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedAlbGatewayParametersApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedAlbGatewayParametersApiResponse = /** status 200 OK */ AlbGatewayParameters;
export type ReadAppthrustDevV1NamespacedAlbGatewayParametersApiArg = {
  /** name of the AlbGatewayParameters */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedAlbGatewayParametersApiResponse = /** status 200 OK */
  | AlbGatewayParameters
  | /** status 201 Created */ AlbGatewayParameters;
export type ReplaceAppthrustDevV1NamespacedAlbGatewayParametersApiArg = {
  /** name of the AlbGatewayParameters */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1AlbGatewayParameters: AlbGatewayParameters;
};
export type DeleteAppthrustDevV1NamespacedAlbGatewayParametersApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedAlbGatewayParametersApiArg = {
  /** name of the AlbGatewayParameters */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedAlbGatewayParametersApiResponse = /** status 200 OK */ AlbGatewayParameters;
export type PatchAppthrustDevV1NamespacedAlbGatewayParametersApiArg = {
  /** name of the AlbGatewayParameters */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedAlbGatewayParametersStatusApiResponse =
  /** status 200 OK */ AlbGatewayParameters;
export type ReadAppthrustDevV1NamespacedAlbGatewayParametersStatusApiArg = {
  /** name of the AlbGatewayParameters */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedAlbGatewayParametersStatusApiResponse = /** status 200 OK */
  | AlbGatewayParameters
  | /** status 201 Created */ AlbGatewayParameters;
export type ReplaceAppthrustDevV1NamespacedAlbGatewayParametersStatusApiArg = {
  /** name of the AlbGatewayParameters */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1AlbGatewayParameters: AlbGatewayParameters;
};
export type PatchAppthrustDevV1NamespacedAlbGatewayParametersStatusApiResponse =
  /** status 200 OK */ AlbGatewayParameters;
export type PatchAppthrustDevV1NamespacedAlbGatewayParametersStatusApiArg = {
  /** name of the AlbGatewayParameters */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse =
  /** status 200 OK */ DevAppthrustV1AwsRoute53ZoneList;
export type ListAppthrustDevV1NamespacedAwsRoute53ZoneApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse = /** status 200 OK */
  | AwsRoute53Zone
  | /** status 201 Created */ AwsRoute53Zone
  | /** status 202 Accepted */ AwsRoute53Zone;
export type CreateAppthrustDevV1NamespacedAwsRoute53ZoneApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1AwsRoute53Zone: AwsRoute53Zone;
};
export type DeleteAppthrustDevV1CollectionNamespacedAwsRoute53ZoneApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedAwsRoute53ZoneApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse = /** status 200 OK */ AwsRoute53Zone;
export type ReadAppthrustDevV1NamespacedAwsRoute53ZoneApiArg = {
  /** name of the AwsRoute53Zone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse = /** status 200 OK */
  | AwsRoute53Zone
  | /** status 201 Created */ AwsRoute53Zone;
export type ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneApiArg = {
  /** name of the AwsRoute53Zone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1AwsRoute53Zone: AwsRoute53Zone;
};
export type DeleteAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedAwsRoute53ZoneApiArg = {
  /** name of the AwsRoute53Zone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedAwsRoute53ZoneApiResponse = /** status 200 OK */ AwsRoute53Zone;
export type PatchAppthrustDevV1NamespacedAwsRoute53ZoneApiArg = {
  /** name of the AwsRoute53Zone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiResponse = /** status 200 OK */ AwsRoute53Zone;
export type ReadAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiArg = {
  /** name of the AwsRoute53Zone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiResponse = /** status 200 OK */
  | AwsRoute53Zone
  | /** status 201 Created */ AwsRoute53Zone;
export type ReplaceAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiArg = {
  /** name of the AwsRoute53Zone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1AwsRoute53Zone: AwsRoute53Zone;
};
export type PatchAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiResponse = /** status 200 OK */ AwsRoute53Zone;
export type PatchAppthrustDevV1NamespacedAwsRoute53ZoneStatusApiArg = {
  /** name of the AwsRoute53Zone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedCertApiResponse = /** status 200 OK */ DevAppthrustV1CertList;
export type ListAppthrustDevV1NamespacedCertApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedCertApiResponse = /** status 200 OK */
  | Cert
  | /** status 201 Created */ Cert
  | /** status 202 Accepted */ Cert;
export type CreateAppthrustDevV1NamespacedCertApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Cert: Cert;
};
export type DeleteAppthrustDevV1CollectionNamespacedCertApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedCertApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedCertApiResponse = /** status 200 OK */ Cert;
export type ReadAppthrustDevV1NamespacedCertApiArg = {
  /** name of the Cert */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedCertApiResponse = /** status 200 OK */ Cert | /** status 201 Created */ Cert;
export type ReplaceAppthrustDevV1NamespacedCertApiArg = {
  /** name of the Cert */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Cert: Cert;
};
export type DeleteAppthrustDevV1NamespacedCertApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedCertApiArg = {
  /** name of the Cert */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedCertApiResponse = /** status 200 OK */ Cert;
export type PatchAppthrustDevV1NamespacedCertApiArg = {
  /** name of the Cert */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedCertStatusApiResponse = /** status 200 OK */ Cert;
export type ReadAppthrustDevV1NamespacedCertStatusApiArg = {
  /** name of the Cert */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedCertStatusApiResponse = /** status 200 OK */
  | Cert
  | /** status 201 Created */ Cert;
export type ReplaceAppthrustDevV1NamespacedCertStatusApiArg = {
  /** name of the Cert */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Cert: Cert;
};
export type PatchAppthrustDevV1NamespacedCertStatusApiResponse = /** status 200 OK */ Cert;
export type PatchAppthrustDevV1NamespacedCertStatusApiArg = {
  /** name of the Cert */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedContainerImageTagApiResponse =
  /** status 200 OK */ DevAppthrustV1ContainerImageTagList;
export type ListAppthrustDevV1NamespacedContainerImageTagApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedContainerImageTagApiResponse = /** status 200 OK */
  | ContainerImageTag
  | /** status 201 Created */ ContainerImageTag
  | /** status 202 Accepted */ ContainerImageTag;
export type CreateAppthrustDevV1NamespacedContainerImageTagApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ContainerImageTag: ContainerImageTag;
};
export type DeleteAppthrustDevV1CollectionNamespacedContainerImageTagApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedContainerImageTagApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedContainerImageTagApiResponse = /** status 200 OK */ ContainerImageTag;
export type ReadAppthrustDevV1NamespacedContainerImageTagApiArg = {
  /** name of the ContainerImageTag */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedContainerImageTagApiResponse = /** status 200 OK */
  | ContainerImageTag
  | /** status 201 Created */ ContainerImageTag;
export type ReplaceAppthrustDevV1NamespacedContainerImageTagApiArg = {
  /** name of the ContainerImageTag */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ContainerImageTag: ContainerImageTag;
};
export type DeleteAppthrustDevV1NamespacedContainerImageTagApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedContainerImageTagApiArg = {
  /** name of the ContainerImageTag */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedContainerImageTagApiResponse = /** status 200 OK */ ContainerImageTag;
export type PatchAppthrustDevV1NamespacedContainerImageTagApiArg = {
  /** name of the ContainerImageTag */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedContainerImageTagStatusApiResponse = /** status 200 OK */ ContainerImageTag;
export type ReadAppthrustDevV1NamespacedContainerImageTagStatusApiArg = {
  /** name of the ContainerImageTag */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedContainerImageTagStatusApiResponse = /** status 200 OK */
  | ContainerImageTag
  | /** status 201 Created */ ContainerImageTag;
export type ReplaceAppthrustDevV1NamespacedContainerImageTagStatusApiArg = {
  /** name of the ContainerImageTag */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ContainerImageTag: ContainerImageTag;
};
export type PatchAppthrustDevV1NamespacedContainerImageTagStatusApiResponse = /** status 200 OK */ ContainerImageTag;
export type PatchAppthrustDevV1NamespacedContainerImageTagStatusApiArg = {
  /** name of the ContainerImageTag */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedContainerRepositoryApiResponse =
  /** status 200 OK */ DevAppthrustV1ContainerRepositoryList;
export type ListAppthrustDevV1NamespacedContainerRepositoryApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedContainerRepositoryApiResponse = /** status 200 OK */
  | ContainerRepository
  | /** status 201 Created */ ContainerRepository
  | /** status 202 Accepted */ ContainerRepository;
export type CreateAppthrustDevV1NamespacedContainerRepositoryApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ContainerRepository: ContainerRepository;
};
export type DeleteAppthrustDevV1CollectionNamespacedContainerRepositoryApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedContainerRepositoryApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedContainerRepositoryApiResponse = /** status 200 OK */ ContainerRepository;
export type ReadAppthrustDevV1NamespacedContainerRepositoryApiArg = {
  /** name of the ContainerRepository */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedContainerRepositoryApiResponse = /** status 200 OK */
  | ContainerRepository
  | /** status 201 Created */ ContainerRepository;
export type ReplaceAppthrustDevV1NamespacedContainerRepositoryApiArg = {
  /** name of the ContainerRepository */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ContainerRepository: ContainerRepository;
};
export type DeleteAppthrustDevV1NamespacedContainerRepositoryApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedContainerRepositoryApiArg = {
  /** name of the ContainerRepository */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedContainerRepositoryApiResponse = /** status 200 OK */ ContainerRepository;
export type PatchAppthrustDevV1NamespacedContainerRepositoryApiArg = {
  /** name of the ContainerRepository */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedContainerRepositoryStatusApiResponse = /** status 200 OK */ ContainerRepository;
export type ReadAppthrustDevV1NamespacedContainerRepositoryStatusApiArg = {
  /** name of the ContainerRepository */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedContainerRepositoryStatusApiResponse = /** status 200 OK */
  | ContainerRepository
  | /** status 201 Created */ ContainerRepository;
export type ReplaceAppthrustDevV1NamespacedContainerRepositoryStatusApiArg = {
  /** name of the ContainerRepository */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ContainerRepository: ContainerRepository;
};
export type PatchAppthrustDevV1NamespacedContainerRepositoryStatusApiResponse =
  /** status 200 OK */ ContainerRepository;
export type PatchAppthrustDevV1NamespacedContainerRepositoryStatusApiArg = {
  /** name of the ContainerRepository */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedDnsZoneApiResponse = /** status 200 OK */ DevAppthrustV1DnsZoneList;
export type ListAppthrustDevV1NamespacedDnsZoneApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedDnsZoneApiResponse = /** status 200 OK */
  | DnsZone
  | /** status 201 Created */ DnsZone
  | /** status 202 Accepted */ DnsZone;
export type CreateAppthrustDevV1NamespacedDnsZoneApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1DnsZone: DnsZone;
};
export type DeleteAppthrustDevV1CollectionNamespacedDnsZoneApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedDnsZoneApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedDnsZoneApiResponse = /** status 200 OK */ DnsZone;
export type ReadAppthrustDevV1NamespacedDnsZoneApiArg = {
  /** name of the DnsZone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedDnsZoneApiResponse = /** status 200 OK */
  | DnsZone
  | /** status 201 Created */ DnsZone;
export type ReplaceAppthrustDevV1NamespacedDnsZoneApiArg = {
  /** name of the DnsZone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1DnsZone: DnsZone;
};
export type DeleteAppthrustDevV1NamespacedDnsZoneApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedDnsZoneApiArg = {
  /** name of the DnsZone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedDnsZoneApiResponse = /** status 200 OK */ DnsZone;
export type PatchAppthrustDevV1NamespacedDnsZoneApiArg = {
  /** name of the DnsZone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedDnsZoneStatusApiResponse = /** status 200 OK */ DnsZone;
export type ReadAppthrustDevV1NamespacedDnsZoneStatusApiArg = {
  /** name of the DnsZone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedDnsZoneStatusApiResponse = /** status 200 OK */
  | DnsZone
  | /** status 201 Created */ DnsZone;
export type ReplaceAppthrustDevV1NamespacedDnsZoneStatusApiArg = {
  /** name of the DnsZone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1DnsZone: DnsZone;
};
export type PatchAppthrustDevV1NamespacedDnsZoneStatusApiResponse = /** status 200 OK */ DnsZone;
export type PatchAppthrustDevV1NamespacedDnsZoneStatusApiArg = {
  /** name of the DnsZone */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedDnsZoneTransferApiResponse =
  /** status 200 OK */ DevAppthrustV1DnsZoneTransferList;
export type ListAppthrustDevV1NamespacedDnsZoneTransferApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedDnsZoneTransferApiResponse = /** status 200 OK */
  | DnsZoneTransfer
  | /** status 201 Created */ DnsZoneTransfer
  | /** status 202 Accepted */ DnsZoneTransfer;
export type CreateAppthrustDevV1NamespacedDnsZoneTransferApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1DnsZoneTransfer: DnsZoneTransfer;
};
export type DeleteAppthrustDevV1CollectionNamespacedDnsZoneTransferApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedDnsZoneTransferApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedDnsZoneTransferApiResponse = /** status 200 OK */ DnsZoneTransfer;
export type ReadAppthrustDevV1NamespacedDnsZoneTransferApiArg = {
  /** name of the DnsZoneTransfer */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedDnsZoneTransferApiResponse = /** status 200 OK */
  | DnsZoneTransfer
  | /** status 201 Created */ DnsZoneTransfer;
export type ReplaceAppthrustDevV1NamespacedDnsZoneTransferApiArg = {
  /** name of the DnsZoneTransfer */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1DnsZoneTransfer: DnsZoneTransfer;
};
export type DeleteAppthrustDevV1NamespacedDnsZoneTransferApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedDnsZoneTransferApiArg = {
  /** name of the DnsZoneTransfer */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedDnsZoneTransferApiResponse = /** status 200 OK */ DnsZoneTransfer;
export type PatchAppthrustDevV1NamespacedDnsZoneTransferApiArg = {
  /** name of the DnsZoneTransfer */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedDnsZoneTransferStatusApiResponse = /** status 200 OK */ DnsZoneTransfer;
export type ReadAppthrustDevV1NamespacedDnsZoneTransferStatusApiArg = {
  /** name of the DnsZoneTransfer */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedDnsZoneTransferStatusApiResponse = /** status 200 OK */
  | DnsZoneTransfer
  | /** status 201 Created */ DnsZoneTransfer;
export type ReplaceAppthrustDevV1NamespacedDnsZoneTransferStatusApiArg = {
  /** name of the DnsZoneTransfer */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1DnsZoneTransfer: DnsZoneTransfer;
};
export type PatchAppthrustDevV1NamespacedDnsZoneTransferStatusApiResponse = /** status 200 OK */ DnsZoneTransfer;
export type PatchAppthrustDevV1NamespacedDnsZoneTransferStatusApiArg = {
  /** name of the DnsZoneTransfer */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedDomainApiResponse = /** status 200 OK */ DevAppthrustV1DomainList;
export type ListAppthrustDevV1NamespacedDomainApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedDomainApiResponse = /** status 200 OK */
  | Domain
  | /** status 201 Created */ Domain
  | /** status 202 Accepted */ Domain;
export type CreateAppthrustDevV1NamespacedDomainApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Domain: Domain;
};
export type DeleteAppthrustDevV1CollectionNamespacedDomainApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedDomainApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedDomainApiResponse = /** status 200 OK */ Domain;
export type ReadAppthrustDevV1NamespacedDomainApiArg = {
  /** name of the Domain */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedDomainApiResponse = /** status 200 OK */
  | Domain
  | /** status 201 Created */ Domain;
export type ReplaceAppthrustDevV1NamespacedDomainApiArg = {
  /** name of the Domain */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Domain: Domain;
};
export type DeleteAppthrustDevV1NamespacedDomainApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedDomainApiArg = {
  /** name of the Domain */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedDomainApiResponse = /** status 200 OK */ Domain;
export type PatchAppthrustDevV1NamespacedDomainApiArg = {
  /** name of the Domain */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedDomainStatusApiResponse = /** status 200 OK */ Domain;
export type ReadAppthrustDevV1NamespacedDomainStatusApiArg = {
  /** name of the Domain */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedDomainStatusApiResponse = /** status 200 OK */
  | Domain
  | /** status 201 Created */ Domain;
export type ReplaceAppthrustDevV1NamespacedDomainStatusApiArg = {
  /** name of the Domain */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Domain: Domain;
};
export type PatchAppthrustDevV1NamespacedDomainStatusApiResponse = /** status 200 OK */ Domain;
export type PatchAppthrustDevV1NamespacedDomainStatusApiArg = {
  /** name of the Domain */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedEksApiResponse = /** status 200 OK */ DevAppthrustV1EksList;
export type ListAppthrustDevV1NamespacedEksApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedEksApiResponse = /** status 200 OK */
  | Eks
  | /** status 201 Created */ Eks
  | /** status 202 Accepted */ Eks;
export type CreateAppthrustDevV1NamespacedEksApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Eks: Eks;
};
export type DeleteAppthrustDevV1CollectionNamespacedEksApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedEksApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedEksApiResponse = /** status 200 OK */ Eks;
export type ReadAppthrustDevV1NamespacedEksApiArg = {
  /** name of the Eks */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedEksApiResponse = /** status 200 OK */ Eks | /** status 201 Created */ Eks;
export type ReplaceAppthrustDevV1NamespacedEksApiArg = {
  /** name of the Eks */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Eks: Eks;
};
export type DeleteAppthrustDevV1NamespacedEksApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedEksApiArg = {
  /** name of the Eks */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedEksApiResponse = /** status 200 OK */ Eks;
export type PatchAppthrustDevV1NamespacedEksApiArg = {
  /** name of the Eks */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedEksStatusApiResponse = /** status 200 OK */ Eks;
export type ReadAppthrustDevV1NamespacedEksStatusApiArg = {
  /** name of the Eks */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedEksStatusApiResponse = /** status 200 OK */
  | Eks
  | /** status 201 Created */ Eks;
export type ReplaceAppthrustDevV1NamespacedEksStatusApiArg = {
  /** name of the Eks */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Eks: Eks;
};
export type PatchAppthrustDevV1NamespacedEksStatusApiResponse = /** status 200 OK */ Eks;
export type PatchAppthrustDevV1NamespacedEksStatusApiArg = {
  /** name of the Eks */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedHttprouteToIngressApiResponse =
  /** status 200 OK */ DevAppthrustV1HttprouteToIngressList;
export type ListAppthrustDevV1NamespacedHttprouteToIngressApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedHttprouteToIngressApiResponse = /** status 200 OK */
  | HttprouteToIngress
  | /** status 201 Created */ HttprouteToIngress
  | /** status 202 Accepted */ HttprouteToIngress;
export type CreateAppthrustDevV1NamespacedHttprouteToIngressApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1HttprouteToIngress: HttprouteToIngress;
};
export type DeleteAppthrustDevV1CollectionNamespacedHttprouteToIngressApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedHttprouteToIngressApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedHttprouteToIngressApiResponse = /** status 200 OK */ HttprouteToIngress;
export type ReadAppthrustDevV1NamespacedHttprouteToIngressApiArg = {
  /** name of the HttprouteToIngress */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedHttprouteToIngressApiResponse = /** status 200 OK */
  | HttprouteToIngress
  | /** status 201 Created */ HttprouteToIngress;
export type ReplaceAppthrustDevV1NamespacedHttprouteToIngressApiArg = {
  /** name of the HttprouteToIngress */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1HttprouteToIngress: HttprouteToIngress;
};
export type DeleteAppthrustDevV1NamespacedHttprouteToIngressApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedHttprouteToIngressApiArg = {
  /** name of the HttprouteToIngress */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedHttprouteToIngressApiResponse = /** status 200 OK */ HttprouteToIngress;
export type PatchAppthrustDevV1NamespacedHttprouteToIngressApiArg = {
  /** name of the HttprouteToIngress */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedHttprouteToIngressStatusApiResponse = /** status 200 OK */ HttprouteToIngress;
export type ReadAppthrustDevV1NamespacedHttprouteToIngressStatusApiArg = {
  /** name of the HttprouteToIngress */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedHttprouteToIngressStatusApiResponse = /** status 200 OK */
  | HttprouteToIngress
  | /** status 201 Created */ HttprouteToIngress;
export type ReplaceAppthrustDevV1NamespacedHttprouteToIngressStatusApiArg = {
  /** name of the HttprouteToIngress */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1HttprouteToIngress: HttprouteToIngress;
};
export type PatchAppthrustDevV1NamespacedHttprouteToIngressStatusApiResponse = /** status 200 OK */ HttprouteToIngress;
export type PatchAppthrustDevV1NamespacedHttprouteToIngressStatusApiArg = {
  /** name of the HttprouteToIngress */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedIamDataApiResponse = /** status 200 OK */ DevAppthrustV1IamDataList;
export type ListAppthrustDevV1NamespacedIamDataApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedIamDataApiResponse = /** status 200 OK */
  | IamData
  | /** status 201 Created */ IamData
  | /** status 202 Accepted */ IamData;
export type CreateAppthrustDevV1NamespacedIamDataApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1IamData: IamData;
};
export type DeleteAppthrustDevV1CollectionNamespacedIamDataApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedIamDataApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedIamDataApiResponse = /** status 200 OK */ IamData;
export type ReadAppthrustDevV1NamespacedIamDataApiArg = {
  /** name of the IamData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedIamDataApiResponse = /** status 200 OK */
  | IamData
  | /** status 201 Created */ IamData;
export type ReplaceAppthrustDevV1NamespacedIamDataApiArg = {
  /** name of the IamData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1IamData: IamData;
};
export type DeleteAppthrustDevV1NamespacedIamDataApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedIamDataApiArg = {
  /** name of the IamData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedIamDataApiResponse = /** status 200 OK */ IamData;
export type PatchAppthrustDevV1NamespacedIamDataApiArg = {
  /** name of the IamData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedIamDataStatusApiResponse = /** status 200 OK */ IamData;
export type ReadAppthrustDevV1NamespacedIamDataStatusApiArg = {
  /** name of the IamData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedIamDataStatusApiResponse = /** status 200 OK */
  | IamData
  | /** status 201 Created */ IamData;
export type ReplaceAppthrustDevV1NamespacedIamDataStatusApiArg = {
  /** name of the IamData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1IamData: IamData;
};
export type PatchAppthrustDevV1NamespacedIamDataStatusApiResponse = /** status 200 OK */ IamData;
export type PatchAppthrustDevV1NamespacedIamDataStatusApiArg = {
  /** name of the IamData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedIamApiResponse = /** status 200 OK */ DevAppthrustV1IamList;
export type ListAppthrustDevV1NamespacedIamApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedIamApiResponse = /** status 200 OK */
  | Iam
  | /** status 201 Created */ Iam
  | /** status 202 Accepted */ Iam;
export type CreateAppthrustDevV1NamespacedIamApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Iam: Iam;
};
export type DeleteAppthrustDevV1CollectionNamespacedIamApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedIamApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedIamApiResponse = /** status 200 OK */ Iam;
export type ReadAppthrustDevV1NamespacedIamApiArg = {
  /** name of the Iam */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedIamApiResponse = /** status 200 OK */ Iam | /** status 201 Created */ Iam;
export type ReplaceAppthrustDevV1NamespacedIamApiArg = {
  /** name of the Iam */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Iam: Iam;
};
export type DeleteAppthrustDevV1NamespacedIamApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedIamApiArg = {
  /** name of the Iam */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedIamApiResponse = /** status 200 OK */ Iam;
export type PatchAppthrustDevV1NamespacedIamApiArg = {
  /** name of the Iam */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedIamStatusApiResponse = /** status 200 OK */ Iam;
export type ReadAppthrustDevV1NamespacedIamStatusApiArg = {
  /** name of the Iam */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedIamStatusApiResponse = /** status 200 OK */
  | Iam
  | /** status 201 Created */ Iam;
export type ReplaceAppthrustDevV1NamespacedIamStatusApiArg = {
  /** name of the Iam */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Iam: Iam;
};
export type PatchAppthrustDevV1NamespacedIamStatusApiResponse = /** status 200 OK */ Iam;
export type PatchAppthrustDevV1NamespacedIamStatusApiArg = {
  /** name of the Iam */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedKeycloakClientSecretApiResponse =
  /** status 200 OK */ DevAppthrustV1KeycloakClientSecretList;
export type ListAppthrustDevV1NamespacedKeycloakClientSecretApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedKeycloakClientSecretApiResponse = /** status 200 OK */
  | KeycloakClientSecret
  | /** status 201 Created */ KeycloakClientSecret
  | /** status 202 Accepted */ KeycloakClientSecret;
export type CreateAppthrustDevV1NamespacedKeycloakClientSecretApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakClientSecret: KeycloakClientSecret;
};
export type DeleteAppthrustDevV1CollectionNamespacedKeycloakClientSecretApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedKeycloakClientSecretApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedKeycloakClientSecretApiResponse = /** status 200 OK */ KeycloakClientSecret;
export type ReadAppthrustDevV1NamespacedKeycloakClientSecretApiArg = {
  /** name of the KeycloakClientSecret */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedKeycloakClientSecretApiResponse = /** status 200 OK */
  | KeycloakClientSecret
  | /** status 201 Created */ KeycloakClientSecret;
export type ReplaceAppthrustDevV1NamespacedKeycloakClientSecretApiArg = {
  /** name of the KeycloakClientSecret */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakClientSecret: KeycloakClientSecret;
};
export type DeleteAppthrustDevV1NamespacedKeycloakClientSecretApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedKeycloakClientSecretApiArg = {
  /** name of the KeycloakClientSecret */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedKeycloakClientSecretApiResponse = /** status 200 OK */ KeycloakClientSecret;
export type PatchAppthrustDevV1NamespacedKeycloakClientSecretApiArg = {
  /** name of the KeycloakClientSecret */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedKeycloakClientSecretStatusApiResponse =
  /** status 200 OK */ KeycloakClientSecret;
export type ReadAppthrustDevV1NamespacedKeycloakClientSecretStatusApiArg = {
  /** name of the KeycloakClientSecret */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedKeycloakClientSecretStatusApiResponse = /** status 200 OK */
  | KeycloakClientSecret
  | /** status 201 Created */ KeycloakClientSecret;
export type ReplaceAppthrustDevV1NamespacedKeycloakClientSecretStatusApiArg = {
  /** name of the KeycloakClientSecret */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakClientSecret: KeycloakClientSecret;
};
export type PatchAppthrustDevV1NamespacedKeycloakClientSecretStatusApiResponse =
  /** status 200 OK */ KeycloakClientSecret;
export type PatchAppthrustDevV1NamespacedKeycloakClientSecretStatusApiArg = {
  /** name of the KeycloakClientSecret */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedKeycloakKeyIdApiResponse = /** status 200 OK */ DevAppthrustV1KeycloakKeyIdList;
export type ListAppthrustDevV1NamespacedKeycloakKeyIdApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedKeycloakKeyIdApiResponse = /** status 200 OK */
  | KeycloakKeyId
  | /** status 201 Created */ KeycloakKeyId
  | /** status 202 Accepted */ KeycloakKeyId;
export type CreateAppthrustDevV1NamespacedKeycloakKeyIdApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakKeyId: KeycloakKeyId;
};
export type DeleteAppthrustDevV1CollectionNamespacedKeycloakKeyIdApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedKeycloakKeyIdApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedKeycloakKeyIdApiResponse = /** status 200 OK */ KeycloakKeyId;
export type ReadAppthrustDevV1NamespacedKeycloakKeyIdApiArg = {
  /** name of the KeycloakKeyId */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedKeycloakKeyIdApiResponse = /** status 200 OK */
  | KeycloakKeyId
  | /** status 201 Created */ KeycloakKeyId;
export type ReplaceAppthrustDevV1NamespacedKeycloakKeyIdApiArg = {
  /** name of the KeycloakKeyId */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakKeyId: KeycloakKeyId;
};
export type DeleteAppthrustDevV1NamespacedKeycloakKeyIdApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedKeycloakKeyIdApiArg = {
  /** name of the KeycloakKeyId */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedKeycloakKeyIdApiResponse = /** status 200 OK */ KeycloakKeyId;
export type PatchAppthrustDevV1NamespacedKeycloakKeyIdApiArg = {
  /** name of the KeycloakKeyId */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedKeycloakKeyIdStatusApiResponse = /** status 200 OK */ KeycloakKeyId;
export type ReadAppthrustDevV1NamespacedKeycloakKeyIdStatusApiArg = {
  /** name of the KeycloakKeyId */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedKeycloakKeyIdStatusApiResponse = /** status 200 OK */
  | KeycloakKeyId
  | /** status 201 Created */ KeycloakKeyId;
export type ReplaceAppthrustDevV1NamespacedKeycloakKeyIdStatusApiArg = {
  /** name of the KeycloakKeyId */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakKeyId: KeycloakKeyId;
};
export type PatchAppthrustDevV1NamespacedKeycloakKeyIdStatusApiResponse = /** status 200 OK */ KeycloakKeyId;
export type PatchAppthrustDevV1NamespacedKeycloakKeyIdStatusApiArg = {
  /** name of the KeycloakKeyId */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse =
  /** status 200 OK */ DevAppthrustV1KeycloakPasswordInitList;
export type ListAppthrustDevV1NamespacedKeycloakPasswordInitApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse = /** status 200 OK */
  | KeycloakPasswordInit
  | /** status 201 Created */ KeycloakPasswordInit
  | /** status 202 Accepted */ KeycloakPasswordInit;
export type CreateAppthrustDevV1NamespacedKeycloakPasswordInitApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakPasswordInit: KeycloakPasswordInit;
};
export type DeleteAppthrustDevV1CollectionNamespacedKeycloakPasswordInitApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedKeycloakPasswordInitApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse = /** status 200 OK */ KeycloakPasswordInit;
export type ReadAppthrustDevV1NamespacedKeycloakPasswordInitApiArg = {
  /** name of the KeycloakPasswordInit */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse = /** status 200 OK */
  | KeycloakPasswordInit
  | /** status 201 Created */ KeycloakPasswordInit;
export type ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitApiArg = {
  /** name of the KeycloakPasswordInit */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakPasswordInit: KeycloakPasswordInit;
};
export type DeleteAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedKeycloakPasswordInitApiArg = {
  /** name of the KeycloakPasswordInit */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedKeycloakPasswordInitApiResponse = /** status 200 OK */ KeycloakPasswordInit;
export type PatchAppthrustDevV1NamespacedKeycloakPasswordInitApiArg = {
  /** name of the KeycloakPasswordInit */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiResponse =
  /** status 200 OK */ KeycloakPasswordInit;
export type ReadAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiArg = {
  /** name of the KeycloakPasswordInit */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiResponse = /** status 200 OK */
  | KeycloakPasswordInit
  | /** status 201 Created */ KeycloakPasswordInit;
export type ReplaceAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiArg = {
  /** name of the KeycloakPasswordInit */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1KeycloakPasswordInit: KeycloakPasswordInit;
};
export type PatchAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiResponse =
  /** status 200 OK */ KeycloakPasswordInit;
export type PatchAppthrustDevV1NamespacedKeycloakPasswordInitStatusApiArg = {
  /** name of the KeycloakPasswordInit */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse =
  /** status 200 OK */ DevAppthrustV1NextAuthSecretRequestList;
export type ListAppthrustDevV1NamespacedNextAuthSecretRequestApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse = /** status 200 OK */
  | NextAuthSecretRequest
  | /** status 201 Created */ NextAuthSecretRequest
  | /** status 202 Accepted */ NextAuthSecretRequest;
export type CreateAppthrustDevV1NamespacedNextAuthSecretRequestApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1NextAuthSecretRequest: NextAuthSecretRequest;
};
export type DeleteAppthrustDevV1CollectionNamespacedNextAuthSecretRequestApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedNextAuthSecretRequestApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse = /** status 200 OK */ NextAuthSecretRequest;
export type ReadAppthrustDevV1NamespacedNextAuthSecretRequestApiArg = {
  /** name of the NextAuthSecretRequest */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse = /** status 200 OK */
  | NextAuthSecretRequest
  | /** status 201 Created */ NextAuthSecretRequest;
export type ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestApiArg = {
  /** name of the NextAuthSecretRequest */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1NextAuthSecretRequest: NextAuthSecretRequest;
};
export type DeleteAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedNextAuthSecretRequestApiArg = {
  /** name of the NextAuthSecretRequest */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedNextAuthSecretRequestApiResponse = /** status 200 OK */ NextAuthSecretRequest;
export type PatchAppthrustDevV1NamespacedNextAuthSecretRequestApiArg = {
  /** name of the NextAuthSecretRequest */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiResponse =
  /** status 200 OK */ NextAuthSecretRequest;
export type ReadAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiArg = {
  /** name of the NextAuthSecretRequest */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiResponse = /** status 200 OK */
  | NextAuthSecretRequest
  | /** status 201 Created */ NextAuthSecretRequest;
export type ReplaceAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiArg = {
  /** name of the NextAuthSecretRequest */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1NextAuthSecretRequest: NextAuthSecretRequest;
};
export type PatchAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiResponse =
  /** status 200 OK */ NextAuthSecretRequest;
export type PatchAppthrustDevV1NamespacedNextAuthSecretRequestStatusApiArg = {
  /** name of the NextAuthSecretRequest */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedProjectApiResponse = /** status 200 OK */ DevAppthrustV1ProjectList;
export type ListAppthrustDevV1NamespacedProjectApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedProjectApiResponse = /** status 200 OK */
  | Project
  | /** status 201 Created */ Project
  | /** status 202 Accepted */ Project;
export type CreateAppthrustDevV1NamespacedProjectApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Project: Project;
};
export type DeleteAppthrustDevV1CollectionNamespacedProjectApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedProjectApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedProjectApiResponse = /** status 200 OK */ Project;
export type ReadAppthrustDevV1NamespacedProjectApiArg = {
  /** name of the Project */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedProjectApiResponse = /** status 200 OK */
  | Project
  | /** status 201 Created */ Project;
export type ReplaceAppthrustDevV1NamespacedProjectApiArg = {
  /** name of the Project */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Project: Project;
};
export type DeleteAppthrustDevV1NamespacedProjectApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedProjectApiArg = {
  /** name of the Project */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedProjectApiResponse = /** status 200 OK */ Project;
export type PatchAppthrustDevV1NamespacedProjectApiArg = {
  /** name of the Project */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedProjectStatusApiResponse = /** status 200 OK */ Project;
export type ReadAppthrustDevV1NamespacedProjectStatusApiArg = {
  /** name of the Project */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedProjectStatusApiResponse = /** status 200 OK */
  | Project
  | /** status 201 Created */ Project;
export type ReplaceAppthrustDevV1NamespacedProjectStatusApiArg = {
  /** name of the Project */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Project: Project;
};
export type PatchAppthrustDevV1NamespacedProjectStatusApiResponse = /** status 200 OK */ Project;
export type PatchAppthrustDevV1NamespacedProjectStatusApiArg = {
  /** name of the Project */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedReleaseChannelApiResponse =
  /** status 200 OK */ DevAppthrustV1ReleaseChannelList;
export type ListAppthrustDevV1NamespacedReleaseChannelApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedReleaseChannelApiResponse = /** status 200 OK */
  | ReleaseChannel
  | /** status 201 Created */ ReleaseChannel
  | /** status 202 Accepted */ ReleaseChannel;
export type CreateAppthrustDevV1NamespacedReleaseChannelApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ReleaseChannel: ReleaseChannel;
};
export type DeleteAppthrustDevV1CollectionNamespacedReleaseChannelApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedReleaseChannelApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedReleaseChannelApiResponse = /** status 200 OK */ ReleaseChannel;
export type ReadAppthrustDevV1NamespacedReleaseChannelApiArg = {
  /** name of the ReleaseChannel */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedReleaseChannelApiResponse = /** status 200 OK */
  | ReleaseChannel
  | /** status 201 Created */ ReleaseChannel;
export type ReplaceAppthrustDevV1NamespacedReleaseChannelApiArg = {
  /** name of the ReleaseChannel */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ReleaseChannel: ReleaseChannel;
};
export type DeleteAppthrustDevV1NamespacedReleaseChannelApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedReleaseChannelApiArg = {
  /** name of the ReleaseChannel */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedReleaseChannelApiResponse = /** status 200 OK */ ReleaseChannel;
export type PatchAppthrustDevV1NamespacedReleaseChannelApiArg = {
  /** name of the ReleaseChannel */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedReleaseChannelStatusApiResponse = /** status 200 OK */ ReleaseChannel;
export type ReadAppthrustDevV1NamespacedReleaseChannelStatusApiArg = {
  /** name of the ReleaseChannel */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedReleaseChannelStatusApiResponse = /** status 200 OK */
  | ReleaseChannel
  | /** status 201 Created */ ReleaseChannel;
export type ReplaceAppthrustDevV1NamespacedReleaseChannelStatusApiArg = {
  /** name of the ReleaseChannel */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ReleaseChannel: ReleaseChannel;
};
export type PatchAppthrustDevV1NamespacedReleaseChannelStatusApiResponse = /** status 200 OK */ ReleaseChannel;
export type PatchAppthrustDevV1NamespacedReleaseChannelStatusApiArg = {
  /** name of the ReleaseChannel */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedResourceValueSyncApiResponse =
  /** status 200 OK */ DevAppthrustV1ResourceValueSyncList;
export type ListAppthrustDevV1NamespacedResourceValueSyncApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedResourceValueSyncApiResponse = /** status 200 OK */
  | ResourceValueSync
  | /** status 201 Created */ ResourceValueSync
  | /** status 202 Accepted */ ResourceValueSync;
export type CreateAppthrustDevV1NamespacedResourceValueSyncApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ResourceValueSync: ResourceValueSync;
};
export type DeleteAppthrustDevV1CollectionNamespacedResourceValueSyncApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedResourceValueSyncApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedResourceValueSyncApiResponse = /** status 200 OK */ ResourceValueSync;
export type ReadAppthrustDevV1NamespacedResourceValueSyncApiArg = {
  /** name of the ResourceValueSync */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedResourceValueSyncApiResponse = /** status 200 OK */
  | ResourceValueSync
  | /** status 201 Created */ ResourceValueSync;
export type ReplaceAppthrustDevV1NamespacedResourceValueSyncApiArg = {
  /** name of the ResourceValueSync */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ResourceValueSync: ResourceValueSync;
};
export type DeleteAppthrustDevV1NamespacedResourceValueSyncApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedResourceValueSyncApiArg = {
  /** name of the ResourceValueSync */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedResourceValueSyncApiResponse = /** status 200 OK */ ResourceValueSync;
export type PatchAppthrustDevV1NamespacedResourceValueSyncApiArg = {
  /** name of the ResourceValueSync */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedResourceValueSyncStatusApiResponse = /** status 200 OK */ ResourceValueSync;
export type ReadAppthrustDevV1NamespacedResourceValueSyncStatusApiArg = {
  /** name of the ResourceValueSync */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedResourceValueSyncStatusApiResponse = /** status 200 OK */
  | ResourceValueSync
  | /** status 201 Created */ ResourceValueSync;
export type ReplaceAppthrustDevV1NamespacedResourceValueSyncStatusApiArg = {
  /** name of the ResourceValueSync */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1ResourceValueSync: ResourceValueSync;
};
export type PatchAppthrustDevV1NamespacedResourceValueSyncStatusApiResponse = /** status 200 OK */ ResourceValueSync;
export type PatchAppthrustDevV1NamespacedResourceValueSyncStatusApiArg = {
  /** name of the ResourceValueSync */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedTfApplyApiResponse = /** status 200 OK */ DevAppthrustV1TfApplyList;
export type ListAppthrustDevV1NamespacedTfApplyApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedTfApplyApiResponse = /** status 200 OK */
  | TfApply
  | /** status 201 Created */ TfApply
  | /** status 202 Accepted */ TfApply;
export type CreateAppthrustDevV1NamespacedTfApplyApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1TfApply: TfApply;
};
export type DeleteAppthrustDevV1CollectionNamespacedTfApplyApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedTfApplyApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedTfApplyApiResponse = /** status 200 OK */ TfApply;
export type ReadAppthrustDevV1NamespacedTfApplyApiArg = {
  /** name of the TfApply */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedTfApplyApiResponse = /** status 200 OK */
  | TfApply
  | /** status 201 Created */ TfApply;
export type ReplaceAppthrustDevV1NamespacedTfApplyApiArg = {
  /** name of the TfApply */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1TfApply: TfApply;
};
export type DeleteAppthrustDevV1NamespacedTfApplyApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedTfApplyApiArg = {
  /** name of the TfApply */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedTfApplyApiResponse = /** status 200 OK */ TfApply;
export type PatchAppthrustDevV1NamespacedTfApplyApiArg = {
  /** name of the TfApply */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedTfApplyStatusApiResponse = /** status 200 OK */ TfApply;
export type ReadAppthrustDevV1NamespacedTfApplyStatusApiArg = {
  /** name of the TfApply */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedTfApplyStatusApiResponse = /** status 200 OK */
  | TfApply
  | /** status 201 Created */ TfApply;
export type ReplaceAppthrustDevV1NamespacedTfApplyStatusApiArg = {
  /** name of the TfApply */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1TfApply: TfApply;
};
export type PatchAppthrustDevV1NamespacedTfApplyStatusApiResponse = /** status 200 OK */ TfApply;
export type PatchAppthrustDevV1NamespacedTfApplyStatusApiArg = {
  /** name of the TfApply */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedTrafficSplittingApiResponse =
  /** status 200 OK */ DevAppthrustV1TrafficSplittingList;
export type ListAppthrustDevV1NamespacedTrafficSplittingApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedTrafficSplittingApiResponse = /** status 200 OK */
  | TrafficSplitting
  | /** status 201 Created */ TrafficSplitting
  | /** status 202 Accepted */ TrafficSplitting;
export type CreateAppthrustDevV1NamespacedTrafficSplittingApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1TrafficSplitting: TrafficSplitting;
};
export type DeleteAppthrustDevV1CollectionNamespacedTrafficSplittingApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedTrafficSplittingApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedTrafficSplittingApiResponse = /** status 200 OK */ TrafficSplitting;
export type ReadAppthrustDevV1NamespacedTrafficSplittingApiArg = {
  /** name of the TrafficSplitting */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedTrafficSplittingApiResponse = /** status 200 OK */
  | TrafficSplitting
  | /** status 201 Created */ TrafficSplitting;
export type ReplaceAppthrustDevV1NamespacedTrafficSplittingApiArg = {
  /** name of the TrafficSplitting */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1TrafficSplitting: TrafficSplitting;
};
export type DeleteAppthrustDevV1NamespacedTrafficSplittingApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedTrafficSplittingApiArg = {
  /** name of the TrafficSplitting */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedTrafficSplittingApiResponse = /** status 200 OK */ TrafficSplitting;
export type PatchAppthrustDevV1NamespacedTrafficSplittingApiArg = {
  /** name of the TrafficSplitting */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedTrafficSplittingStatusApiResponse = /** status 200 OK */ TrafficSplitting;
export type ReadAppthrustDevV1NamespacedTrafficSplittingStatusApiArg = {
  /** name of the TrafficSplitting */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedTrafficSplittingStatusApiResponse = /** status 200 OK */
  | TrafficSplitting
  | /** status 201 Created */ TrafficSplitting;
export type ReplaceAppthrustDevV1NamespacedTrafficSplittingStatusApiArg = {
  /** name of the TrafficSplitting */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1TrafficSplitting: TrafficSplitting;
};
export type PatchAppthrustDevV1NamespacedTrafficSplittingStatusApiResponse = /** status 200 OK */ TrafficSplitting;
export type PatchAppthrustDevV1NamespacedTrafficSplittingStatusApiArg = {
  /** name of the TrafficSplitting */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedVpcDataApiResponse = /** status 200 OK */ DevAppthrustV1VpcDataList;
export type ListAppthrustDevV1NamespacedVpcDataApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedVpcDataApiResponse = /** status 200 OK */
  | VpcData
  | /** status 201 Created */ VpcData
  | /** status 202 Accepted */ VpcData;
export type CreateAppthrustDevV1NamespacedVpcDataApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1VpcData: VpcData;
};
export type DeleteAppthrustDevV1CollectionNamespacedVpcDataApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedVpcDataApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedVpcDataApiResponse = /** status 200 OK */ VpcData;
export type ReadAppthrustDevV1NamespacedVpcDataApiArg = {
  /** name of the VpcData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedVpcDataApiResponse = /** status 200 OK */
  | VpcData
  | /** status 201 Created */ VpcData;
export type ReplaceAppthrustDevV1NamespacedVpcDataApiArg = {
  /** name of the VpcData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1VpcData: VpcData;
};
export type DeleteAppthrustDevV1NamespacedVpcDataApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedVpcDataApiArg = {
  /** name of the VpcData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedVpcDataApiResponse = /** status 200 OK */ VpcData;
export type PatchAppthrustDevV1NamespacedVpcDataApiArg = {
  /** name of the VpcData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedVpcDataStatusApiResponse = /** status 200 OK */ VpcData;
export type ReadAppthrustDevV1NamespacedVpcDataStatusApiArg = {
  /** name of the VpcData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedVpcDataStatusApiResponse = /** status 200 OK */
  | VpcData
  | /** status 201 Created */ VpcData;
export type ReplaceAppthrustDevV1NamespacedVpcDataStatusApiArg = {
  /** name of the VpcData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1VpcData: VpcData;
};
export type PatchAppthrustDevV1NamespacedVpcDataStatusApiResponse = /** status 200 OK */ VpcData;
export type PatchAppthrustDevV1NamespacedVpcDataStatusApiArg = {
  /** name of the VpcData */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedVpcApiResponse = /** status 200 OK */ DevAppthrustV1VpcList;
export type ListAppthrustDevV1NamespacedVpcApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedVpcApiResponse = /** status 200 OK */
  | Vpc
  | /** status 201 Created */ Vpc
  | /** status 202 Accepted */ Vpc;
export type CreateAppthrustDevV1NamespacedVpcApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Vpc: Vpc;
};
export type DeleteAppthrustDevV1CollectionNamespacedVpcApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedVpcApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedVpcApiResponse = /** status 200 OK */ Vpc;
export type ReadAppthrustDevV1NamespacedVpcApiArg = {
  /** name of the Vpc */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedVpcApiResponse = /** status 200 OK */ Vpc | /** status 201 Created */ Vpc;
export type ReplaceAppthrustDevV1NamespacedVpcApiArg = {
  /** name of the Vpc */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Vpc: Vpc;
};
export type DeleteAppthrustDevV1NamespacedVpcApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedVpcApiArg = {
  /** name of the Vpc */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedVpcApiResponse = /** status 200 OK */ Vpc;
export type PatchAppthrustDevV1NamespacedVpcApiArg = {
  /** name of the Vpc */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedVpcStatusApiResponse = /** status 200 OK */ Vpc;
export type ReadAppthrustDevV1NamespacedVpcStatusApiArg = {
  /** name of the Vpc */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedVpcStatusApiResponse = /** status 200 OK */
  | Vpc
  | /** status 201 Created */ Vpc;
export type ReplaceAppthrustDevV1NamespacedVpcStatusApiArg = {
  /** name of the Vpc */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Vpc: Vpc;
};
export type PatchAppthrustDevV1NamespacedVpcStatusApiResponse = /** status 200 OK */ Vpc;
export type PatchAppthrustDevV1NamespacedVpcStatusApiArg = {
  /** name of the Vpc */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWafApiResponse = /** status 200 OK */ DevAppthrustV1WafList;
export type ListAppthrustDevV1NamespacedWafApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWafApiResponse = /** status 200 OK */
  | Waf
  | /** status 201 Created */ Waf
  | /** status 202 Accepted */ Waf;
export type CreateAppthrustDevV1NamespacedWafApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Waf: Waf;
};
export type DeleteAppthrustDevV1CollectionNamespacedWafApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWafApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWafApiResponse = /** status 200 OK */ Waf;
export type ReadAppthrustDevV1NamespacedWafApiArg = {
  /** name of the Waf */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWafApiResponse = /** status 200 OK */ Waf | /** status 201 Created */ Waf;
export type ReplaceAppthrustDevV1NamespacedWafApiArg = {
  /** name of the Waf */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Waf: Waf;
};
export type DeleteAppthrustDevV1NamespacedWafApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWafApiArg = {
  /** name of the Waf */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWafApiResponse = /** status 200 OK */ Waf;
export type PatchAppthrustDevV1NamespacedWafApiArg = {
  /** name of the Waf */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWafStatusApiResponse = /** status 200 OK */ Waf;
export type ReadAppthrustDevV1NamespacedWafStatusApiArg = {
  /** name of the Waf */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWafStatusApiResponse = /** status 200 OK */
  | Waf
  | /** status 201 Created */ Waf;
export type ReplaceAppthrustDevV1NamespacedWafStatusApiArg = {
  /** name of the Waf */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1Waf: Waf;
};
export type PatchAppthrustDevV1NamespacedWafStatusApiResponse = /** status 200 OK */ Waf;
export type PatchAppthrustDevV1NamespacedWafStatusApiArg = {
  /** name of the Waf */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentBuildFinishedList;
export type ListAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse = /** status 200 OK */
  | WebAppComponentBuildFinished
  | /** status 201 Created */ WebAppComponentBuildFinished
  | /** status 202 Accepted */ WebAppComponentBuildFinished;
export type CreateAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentBuildFinished: WebAppComponentBuildFinished;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildFinishedApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildFinishedApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse =
  /** status 200 OK */ WebAppComponentBuildFinished;
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg = {
  /** name of the WebAppComponentBuildFinished */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse = /** status 200 OK */
  | WebAppComponentBuildFinished
  | /** status 201 Created */ WebAppComponentBuildFinished;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg = {
  /** name of the WebAppComponentBuildFinished */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentBuildFinished: WebAppComponentBuildFinished;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg = {
  /** name of the WebAppComponentBuildFinished */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiResponse =
  /** status 200 OK */ WebAppComponentBuildFinished;
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedApiArg = {
  /** name of the WebAppComponentBuildFinished */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiResponse =
  /** status 200 OK */ WebAppComponentBuildFinished;
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiArg = {
  /** name of the WebAppComponentBuildFinished */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiResponse = /** status 200 OK */
  | WebAppComponentBuildFinished
  | /** status 201 Created */ WebAppComponentBuildFinished;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiArg = {
  /** name of the WebAppComponentBuildFinished */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentBuildFinished: WebAppComponentBuildFinished;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiResponse =
  /** status 200 OK */ WebAppComponentBuildFinished;
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildFinishedStatusApiArg = {
  /** name of the WebAppComponentBuildFinished */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentBuildApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentBuildList;
export type ListAppthrustDevV1NamespacedWebAppComponentBuildApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentBuildApiResponse = /** status 200 OK */
  | WebAppComponentBuild
  | /** status 201 Created */ WebAppComponentBuild
  | /** status 202 Accepted */ WebAppComponentBuild;
export type CreateAppthrustDevV1NamespacedWebAppComponentBuildApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentBuild: WebAppComponentBuild;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentBuildApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildApiResponse = /** status 200 OK */ WebAppComponentBuild;
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildApiArg = {
  /** name of the WebAppComponentBuild */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildApiResponse = /** status 200 OK */
  | WebAppComponentBuild
  | /** status 201 Created */ WebAppComponentBuild;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildApiArg = {
  /** name of the WebAppComponentBuild */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentBuild: WebAppComponentBuild;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentBuildApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentBuildApiArg = {
  /** name of the WebAppComponentBuild */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildApiResponse = /** status 200 OK */ WebAppComponentBuild;
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildApiArg = {
  /** name of the WebAppComponentBuild */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildStatusApiResponse =
  /** status 200 OK */ WebAppComponentBuild;
export type ReadAppthrustDevV1NamespacedWebAppComponentBuildStatusApiArg = {
  /** name of the WebAppComponentBuild */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildStatusApiResponse = /** status 200 OK */
  | WebAppComponentBuild
  | /** status 201 Created */ WebAppComponentBuild;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentBuildStatusApiArg = {
  /** name of the WebAppComponentBuild */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentBuild: WebAppComponentBuild;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildStatusApiResponse =
  /** status 200 OK */ WebAppComponentBuild;
export type PatchAppthrustDevV1NamespacedWebAppComponentBuildStatusApiArg = {
  /** name of the WebAppComponentBuild */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentDeploymentList;
export type ListAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse = /** status 200 OK */
  | WebAppComponentDeployment
  | /** status 201 Created */ WebAppComponentDeployment
  | /** status 202 Accepted */ WebAppComponentDeployment;
export type CreateAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentDeployment: WebAppComponentDeployment;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentDeploymentApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentDeploymentApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse =
  /** status 200 OK */ WebAppComponentDeployment;
export type ReadAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg = {
  /** name of the WebAppComponentDeployment */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse = /** status 200 OK */
  | WebAppComponentDeployment
  | /** status 201 Created */ WebAppComponentDeployment;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg = {
  /** name of the WebAppComponentDeployment */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentDeployment: WebAppComponentDeployment;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg = {
  /** name of the WebAppComponentDeployment */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentDeploymentApiResponse =
  /** status 200 OK */ WebAppComponentDeployment;
export type PatchAppthrustDevV1NamespacedWebAppComponentDeploymentApiArg = {
  /** name of the WebAppComponentDeployment */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiResponse =
  /** status 200 OK */ WebAppComponentDeployment;
export type ReadAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiArg = {
  /** name of the WebAppComponentDeployment */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiResponse = /** status 200 OK */
  | WebAppComponentDeployment
  | /** status 201 Created */ WebAppComponentDeployment;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiArg = {
  /** name of the WebAppComponentDeployment */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentDeployment: WebAppComponentDeployment;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiResponse =
  /** status 200 OK */ WebAppComponentDeployment;
export type PatchAppthrustDevV1NamespacedWebAppComponentDeploymentStatusApiArg = {
  /** name of the WebAppComponentDeployment */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentGatewayConnectionList;
export type ListAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse = /** status 200 OK */
  | WebAppComponentGatewayConnection
  | /** status 201 Created */ WebAppComponentGatewayConnection
  | /** status 202 Accepted */ WebAppComponentGatewayConnection;
export type CreateAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentGatewayConnection: WebAppComponentGatewayConnection;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentGatewayConnectionApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentGatewayConnectionApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse =
  /** status 200 OK */ WebAppComponentGatewayConnection;
export type ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg = {
  /** name of the WebAppComponentGatewayConnection */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse = /** status 200 OK */
  | WebAppComponentGatewayConnection
  | /** status 201 Created */ WebAppComponentGatewayConnection;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg = {
  /** name of the WebAppComponentGatewayConnection */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentGatewayConnection: WebAppComponentGatewayConnection;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg = {
  /** name of the WebAppComponentGatewayConnection */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiResponse =
  /** status 200 OK */ WebAppComponentGatewayConnection;
export type PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionApiArg = {
  /** name of the WebAppComponentGatewayConnection */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiResponse =
  /** status 200 OK */ WebAppComponentGatewayConnection;
export type ReadAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiArg = {
  /** name of the WebAppComponentGatewayConnection */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiResponse = /** status 200 OK */
  | WebAppComponentGatewayConnection
  | /** status 201 Created */ WebAppComponentGatewayConnection;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiArg = {
  /** name of the WebAppComponentGatewayConnection */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentGatewayConnection: WebAppComponentGatewayConnection;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiResponse =
  /** status 200 OK */ WebAppComponentGatewayConnection;
export type PatchAppthrustDevV1NamespacedWebAppComponentGatewayConnectionStatusApiArg = {
  /** name of the WebAppComponentGatewayConnection */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentPipelineList;
export type ListAppthrustDevV1NamespacedWebAppComponentPipelineApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse = /** status 200 OK */
  | WebAppComponentPipeline
  | /** status 201 Created */ WebAppComponentPipeline
  | /** status 202 Accepted */ WebAppComponentPipeline;
export type CreateAppthrustDevV1NamespacedWebAppComponentPipelineApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentPipeline: WebAppComponentPipeline;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentPipelineApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentPipelineApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse =
  /** status 200 OK */ WebAppComponentPipeline;
export type ReadAppthrustDevV1NamespacedWebAppComponentPipelineApiArg = {
  /** name of the WebAppComponentPipeline */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse = /** status 200 OK */
  | WebAppComponentPipeline
  | /** status 201 Created */ WebAppComponentPipeline;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineApiArg = {
  /** name of the WebAppComponentPipeline */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentPipeline: WebAppComponentPipeline;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentPipelineApiArg = {
  /** name of the WebAppComponentPipeline */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentPipelineApiResponse =
  /** status 200 OK */ WebAppComponentPipeline;
export type PatchAppthrustDevV1NamespacedWebAppComponentPipelineApiArg = {
  /** name of the WebAppComponentPipeline */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiResponse =
  /** status 200 OK */ WebAppComponentPipeline;
export type ReadAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiArg = {
  /** name of the WebAppComponentPipeline */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiResponse = /** status 200 OK */
  | WebAppComponentPipeline
  | /** status 201 Created */ WebAppComponentPipeline;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiArg = {
  /** name of the WebAppComponentPipeline */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentPipeline: WebAppComponentPipeline;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiResponse =
  /** status 200 OK */ WebAppComponentPipeline;
export type PatchAppthrustDevV1NamespacedWebAppComponentPipelineStatusApiArg = {
  /** name of the WebAppComponentPipeline */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentReleaseChannelBuildConfigList;
export type ListAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse = /** status 200 OK */
  | WebAppComponentReleaseChannelBuildConfig
  | /** status 201 Created */ WebAppComponentReleaseChannelBuildConfig
  | /** status 202 Accepted */ WebAppComponentReleaseChannelBuildConfig;
export type CreateAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentReleaseChannelBuildConfig: WebAppComponentReleaseChannelBuildConfig;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentReleaseChannelBuildConfigApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentReleaseChannelBuildConfigApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse =
  /** status 200 OK */ WebAppComponentReleaseChannelBuildConfig;
export type ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg = {
  /** name of the WebAppComponentReleaseChannelBuildConfig */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse = /** status 200 OK */
  | WebAppComponentReleaseChannelBuildConfig
  | /** status 201 Created */ WebAppComponentReleaseChannelBuildConfig;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg = {
  /** name of the WebAppComponentReleaseChannelBuildConfig */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentReleaseChannelBuildConfig: WebAppComponentReleaseChannelBuildConfig;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg = {
  /** name of the WebAppComponentReleaseChannelBuildConfig */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiResponse =
  /** status 200 OK */ WebAppComponentReleaseChannelBuildConfig;
export type PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigApiArg = {
  /** name of the WebAppComponentReleaseChannelBuildConfig */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiResponse =
  /** status 200 OK */ WebAppComponentReleaseChannelBuildConfig;
export type ReadAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiArg = {
  /** name of the WebAppComponentReleaseChannelBuildConfig */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiResponse =
  /** status 200 OK */
    | WebAppComponentReleaseChannelBuildConfig
    | /** status 201 Created */ WebAppComponentReleaseChannelBuildConfig;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiArg = {
  /** name of the WebAppComponentReleaseChannelBuildConfig */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentReleaseChannelBuildConfig: WebAppComponentReleaseChannelBuildConfig;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiResponse =
  /** status 200 OK */ WebAppComponentReleaseChannelBuildConfig;
export type PatchAppthrustDevV1NamespacedWebAppComponentReleaseChannelBuildConfigStatusApiArg = {
  /** name of the WebAppComponentReleaseChannelBuildConfig */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentRevisionList;
export type ListAppthrustDevV1NamespacedWebAppComponentRevisionApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse = /** status 200 OK */
  | WebAppComponentRevision
  | /** status 201 Created */ WebAppComponentRevision
  | /** status 202 Accepted */ WebAppComponentRevision;
export type CreateAppthrustDevV1NamespacedWebAppComponentRevisionApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentRevision: WebAppComponentRevision;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentRevisionApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentRevisionApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse =
  /** status 200 OK */ WebAppComponentRevision;
export type ReadAppthrustDevV1NamespacedWebAppComponentRevisionApiArg = {
  /** name of the WebAppComponentRevision */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse = /** status 200 OK */
  | WebAppComponentRevision
  | /** status 201 Created */ WebAppComponentRevision;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionApiArg = {
  /** name of the WebAppComponentRevision */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentRevision: WebAppComponentRevision;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentRevisionApiArg = {
  /** name of the WebAppComponentRevision */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentRevisionApiResponse =
  /** status 200 OK */ WebAppComponentRevision;
export type PatchAppthrustDevV1NamespacedWebAppComponentRevisionApiArg = {
  /** name of the WebAppComponentRevision */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiResponse =
  /** status 200 OK */ WebAppComponentRevision;
export type ReadAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiArg = {
  /** name of the WebAppComponentRevision */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiResponse = /** status 200 OK */
  | WebAppComponentRevision
  | /** status 201 Created */ WebAppComponentRevision;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiArg = {
  /** name of the WebAppComponentRevision */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponentRevision: WebAppComponentRevision;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiResponse =
  /** status 200 OK */ WebAppComponentRevision;
export type PatchAppthrustDevV1NamespacedWebAppComponentRevisionStatusApiArg = {
  /** name of the WebAppComponentRevision */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NamespacedWebAppComponentApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentList;
export type ListAppthrustDevV1NamespacedWebAppComponentApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type CreateAppthrustDevV1NamespacedWebAppComponentApiResponse = /** status 200 OK */
  | WebAppComponent
  | /** status 201 Created */ WebAppComponent
  | /** status 202 Accepted */ WebAppComponent;
export type CreateAppthrustDevV1NamespacedWebAppComponentApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponent: WebAppComponent;
};
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentApiResponse =
  /** status 200 OK */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1CollectionNamespacedWebAppComponentApiArg = {
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentApiResponse = /** status 200 OK */ WebAppComponent;
export type ReadAppthrustDevV1NamespacedWebAppComponentApiArg = {
  /** name of the WebAppComponent */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentApiResponse = /** status 200 OK */
  | WebAppComponent
  | /** status 201 Created */ WebAppComponent;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentApiArg = {
  /** name of the WebAppComponent */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponent: WebAppComponent;
};
export type DeleteAppthrustDevV1NamespacedWebAppComponentApiResponse = /** status 200 OK */
  | IoK8SApimachineryPkgApisMetaV1Status
  | /** status 202 Accepted */ IoK8SApimachineryPkgApisMetaV1Status;
export type DeleteAppthrustDevV1NamespacedWebAppComponentApiArg = {
  /** name of the WebAppComponent */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: number;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: boolean;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: string;
  ioK8SApimachineryPkgApisMetaV1DeleteOptions: IoK8SApimachineryPkgApisMetaV1DeleteOptions;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentApiResponse = /** status 200 OK */ WebAppComponent;
export type PatchAppthrustDevV1NamespacedWebAppComponentApiArg = {
  /** name of the WebAppComponent */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ReadAppthrustDevV1NamespacedWebAppComponentStatusApiResponse = /** status 200 OK */ WebAppComponent;
export type ReadAppthrustDevV1NamespacedWebAppComponentStatusApiArg = {
  /** name of the WebAppComponent */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
};
export type ReplaceAppthrustDevV1NamespacedWebAppComponentStatusApiResponse = /** status 200 OK */
  | WebAppComponent
  | /** status 201 Created */ WebAppComponent;
export type ReplaceAppthrustDevV1NamespacedWebAppComponentStatusApiArg = {
  /** name of the WebAppComponent */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  devAppthrustV1WebAppComponent: WebAppComponent;
};
export type PatchAppthrustDevV1NamespacedWebAppComponentStatusApiResponse = /** status 200 OK */ WebAppComponent;
export type PatchAppthrustDevV1NamespacedWebAppComponentStatusApiArg = {
  /** name of the WebAppComponent */
  name: string;
  /** object name and auth scope, such as for teams and projects */
  namespace: string;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: string;
  /** fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). */
  fieldManager?: string;
  /** fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. */
  fieldValidation?: string;
  /** Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. */
  force?: boolean;
  body: Blob;
};
export type ListAppthrustDevV1NextAuthSecretRequestForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1NextAuthSecretRequestList;
export type ListAppthrustDevV1NextAuthSecretRequestForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1ProjectForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1ProjectList;
export type ListAppthrustDevV1ProjectForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1ReleaseChannelForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1ReleaseChannelList;
export type ListAppthrustDevV1ReleaseChannelForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1ResourceValueSyncForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1ResourceValueSyncList;
export type ListAppthrustDevV1ResourceValueSyncForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1TfApplyForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1TfApplyList;
export type ListAppthrustDevV1TfApplyForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1TrafficSplittingForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1TrafficSplittingList;
export type ListAppthrustDevV1TrafficSplittingForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1VpcDataForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1VpcDataList;
export type ListAppthrustDevV1VpcDataForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1VpcForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1VpcList;
export type ListAppthrustDevV1VpcForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WafForAllNamespacesApiResponse = /** status 200 OK */ DevAppthrustV1WafList;
export type ListAppthrustDevV1WafForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentBuildFinishedForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentBuildFinishedList;
export type ListAppthrustDevV1WebAppComponentBuildFinishedForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentBuildForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentBuildList;
export type ListAppthrustDevV1WebAppComponentBuildForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentDeploymentForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentDeploymentList;
export type ListAppthrustDevV1WebAppComponentDeploymentForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentGatewayConnectionForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentGatewayConnectionList;
export type ListAppthrustDevV1WebAppComponentGatewayConnectionForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentPipelineForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentPipelineList;
export type ListAppthrustDevV1WebAppComponentPipelineForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentReleaseChannelBuildConfigForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentReleaseChannelBuildConfigList;
export type ListAppthrustDevV1WebAppComponentReleaseChannelBuildConfigForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentRevisionForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentRevisionList;
export type ListAppthrustDevV1WebAppComponentRevisionForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type ListAppthrustDevV1WebAppComponentForAllNamespacesApiResponse =
  /** status 200 OK */ DevAppthrustV1WebAppComponentList;
export type ListAppthrustDevV1WebAppComponentForAllNamespacesApiArg = {
  /** allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. */
  allowWatchBookmarks?: boolean;
  /** The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
    
    This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. */
  continue?: string;
  /** A selector to restrict the list of returned objects by their fields. Defaults to everything. */
  fieldSelector?: string;
  /** A selector to restrict the list of returned objects by their labels. Defaults to everything. */
  labelSelector?: string;
  /** limit is a maximum number of responses to return for a list call. If more items exist, the server will set the \`continue\` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
    
    The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. */
  limit?: number;
  /** If 'true', then the output is pretty printed. */
  pretty?: string;
  /** resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersion?: string;
  /** resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
    
    Defaults to unset */
  resourceVersionMatch?: string;
  /** \`sendInitialEvents=true\` may be set together with \`watch=true\`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with \`"k8s.io/initial-events-end": "true"\` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
    
    When \`sendInitialEvents\` option is set, we require \`resourceVersionMatch\` option to also be set. The semantic of the watch request is as following: - \`resourceVersionMatch\` = NotOlderThan
      is interpreted as "data at least as new as the provided \`resourceVersion\`"
      and the bookmark event is send when the state is synced
      to a \`resourceVersion\` at least as fresh as the one provided by the ListOptions.
      If \`resourceVersion\` is unset, this is interpreted as "consistent read" and the
      bookmark event is send when the state is synced at least to the moment
      when request started being processed.
    - \`resourceVersionMatch\` set to any other value or unset
      Invalid error is returned.
    
    Defaults to true if \`resourceVersion=""\` or \`resourceVersion="0"\` (for backward compatibility reasons) and to false otherwise. */
  sendInitialEvents?: boolean;
  /** Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. */
  timeoutSeconds?: number;
  /** Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. */
  watch?: boolean;
};
export type IoK8SApimachineryPkgApisMetaV1Time = string;
export type IoK8SApimachineryPkgApisMetaV1FieldsV1 = object;
export type IoK8SApimachineryPkgApisMetaV1ManagedFieldsEntry = {
  apiVersion?: string | undefined;
  fieldsType?: string | undefined;
  fieldsV1?: IoK8SApimachineryPkgApisMetaV1FieldsV1 | undefined;
  manager?: string | undefined;
  operation?: string | undefined;
  subresource?: string | undefined;
  time?: IoK8SApimachineryPkgApisMetaV1Time | undefined;
};
export type IoK8SApimachineryPkgApisMetaV1OwnerReference = {
  apiVersion: string;
  blockOwnerDeletion?: boolean | undefined;
  controller?: boolean | undefined;
  kind: string;
  name: string;
  uid: string;
};
export type IoK8SApimachineryPkgApisMetaV1ObjectMeta = {
  annotations?:
    | {
        [key: string]: string;
      }
    | undefined;
  creationTimestamp?: IoK8SApimachineryPkgApisMetaV1Time | undefined;
  deletionGracePeriodSeconds?: number | undefined;
  deletionTimestamp?: IoK8SApimachineryPkgApisMetaV1Time | undefined;
  finalizers?: string[] | undefined;
  generateName?: string | undefined;
  generation?: number | undefined;
  labels?:
    | {
        [key: string]: string;
      }
    | undefined;
  managedFields?: IoK8SApimachineryPkgApisMetaV1ManagedFieldsEntry[] | undefined;
  name?: string | undefined;
  namespace?: string | undefined;
  ownerReferences?: IoK8SApimachineryPkgApisMetaV1OwnerReference[] | undefined;
  resourceVersion?: string | undefined;
  selfLink?: string | undefined;
  uid?: string | undefined;
};
export type AlbGatewayParameters = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    create_s3_bucket?: (boolean | null) | undefined;
    deletion_protection?: (boolean | null) | undefined;
    health_check_node_port_service?:
      | ({
          name: string;
          namespace: string;
        } | null)
      | undefined;
    idle_timeout_seconds?: (number | null) | undefined;
    s3_access_logs_prefix?: (string | null) | undefined;
    s3_bucket_name?: (string | null) | undefined;
    scheme: 'internal' | 'internet-facing';
    shield_advanced_protection?: (boolean | null) | undefined;
    subnet_ids?: (string[] | null) | undefined;
    tags?: (string | null) | undefined;
    waf_acl_id?: (string | null) | undefined;
    wafv2_acl_arn?: (string | null) | undefined;
  };
  status?: (object | null) | undefined;
};
export type IoK8SApimachineryPkgApisMetaV1ListMeta = {
  continue?: string | undefined;
  remainingItemCount?: number | undefined;
  resourceVersion?: string | undefined;
  selfLink?: string | undefined;
};
export type DevAppthrustV1AlbGatewayParametersList = {
  apiVersion?: string | undefined;
  items: AlbGatewayParameters[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type AwsRoute53Zone = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    domainName: string;
    forceDelete: boolean;
    secretEnvRef?:
      | ({
          name: string;
          namespace: string;
        } | null)
      | undefined;
    vpcs: {
      vpcId: string;
      vpcRegion: string;
    }[];
    zoneId?: (string | null) | undefined;
  };
  status?:
    | ({
        awsCallerIdentity?: (string | null) | undefined;
        conditions: {
          lastTransitionTime: string;
          message: string;
          observedGeneration?: (number | null) | undefined;
          reason:
            | 'Pending'
            | 'ProviderAuthFailed'
            | 'KubernetesPermissionDenied'
            | 'CreationSucceeded'
            | 'CreationFailed'
            | 'DelegationSucceeded'
            | 'DelegationFailed'
            | 'ZoneMissing'
            | 'ProvidersReconciled';
          status: 'True' | 'False' | 'Unknown';
          type: 'Accepted' | 'Failed' | 'Ready' | 'Modified';
        }[];
        progressing: 'WaitingForController' | 'ZoneCreation' | 'ZoneReference' | 'ZoneDelegation' | 'InvalidSpec';
        progressingStatus: 'Pending' | 'InProgress' | 'Completed' | 'Failed';
        zoneId?: (string | null) | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1AwsRoute53ZoneList = {
  apiVersion?: string | undefined;
  items: AwsRoute53Zone[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type Cert = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    dependencies?:
      | (
          | {
              gvk: {
                group: string;
                kind: string;
                version: string;
              };
              name: string;
              namespace: string;
              output_field_name: string;
              status_completed_field_name: string;
            }[]
          | null
        )
      | undefined;
    variables: {
      aws_account_id: string;
      aws_external_id: string;
      domain: string;
      role_name: string;
    };
  };
  status?:
    | ({
        delegated_resource_name?: (string | null) | undefined;
        driver_completed?: (boolean | null) | undefined;
        driver_delegated?: (boolean | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1CertList = {
  apiVersion?: string | undefined;
  items: Cert[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type ContainerImageTag = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    container_repository_id: string;
    name: string;
  };
  status?:
    | ({
        state: 'Reserved' | 'Ready' | 'Canceled';
      } | null)
    | undefined;
};
export type DevAppthrustV1ContainerImageTagList = {
  apiVersion?: string | undefined;
  items: ContainerImageTag[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type ContainerRepository = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    domain: string;
    git_repository_id: string;
    id: string;
    name: string;
    root_directory: string;
    type: 'EcrLocal';
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1ContainerRepositoryList = {
  apiVersion?: string | undefined;
  items: ContainerRepository[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type DnsZone = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    dependencies?:
      | (
          | {
              gvk: {
                group: string;
                kind: string;
                version: string;
              };
              name: string;
              namespace: string;
              output_field_name: string;
              status_completed_field_name: string;
            }[]
          | null
        )
      | undefined;
    variables: {
      assume_role_arn: string;
      aws_external_id: string;
      aws_route53_query_log_retention_in_days: number;
      domain: string;
    };
  };
  status?:
    | ({
        delegated_resource_name?: (string | null) | undefined;
        driver_completed?: (boolean | null) | undefined;
        driver_delegated?: (boolean | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1DnsZoneList = {
  apiVersion?: string | undefined;
  items: DnsZone[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type DnsZoneTransfer = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    dependencies?:
      | (
          | {
              gvk: {
                group: string;
                kind: string;
                version: string;
              };
              name: string;
              namespace: string;
              output_field_name: string;
              status_completed_field_name: string;
            }[]
          | null
        )
      | undefined;
    variables: {
      aws_account_id: string;
      aws_external_id: string;
      parent_domain: string;
      role_name: string;
      subdomain: string;
      ttl: number;
    };
  };
  status?:
    | ({
        delegated_resource_name?: (string | null) | undefined;
        driver_completed?: (boolean | null) | undefined;
        driver_delegated?: (boolean | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1DnsZoneTransferList = {
  apiVersion?: string | undefined;
  items: DnsZoneTransfer[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type Domain = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    description: string;
    dnsProviders: {
      forceDelete: boolean;
      name: string;
      options?:
        | ({
            [key: string]: string;
          } | null)
        | undefined;
      secretEnvRef?:
        | ({
            name: string;
            namespace: string;
          } | null)
        | undefined;
      type: 'awsRoute53Zone';
    }[];
    domainName: string;
  };
  status?:
    | ({
        conditions: {
          lastTransitionTime: string;
          message: string;
          observedGeneration?: (number | null) | undefined;
          reason: 'ProvidersReconciled' | 'Pending';
          status: 'True' | 'False' | 'Unknown';
          type: 'Accepted' | 'Failed' | 'Ready' | 'Modified';
        }[];
      } | null)
    | undefined;
};
export type DevAppthrustV1DomainList = {
  apiVersion?: string | undefined;
  items: Domain[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type Eks = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    assume_role_variables: {
      assume_role_arn: string;
    };
    cluster_deployment_id: string;
    dependencies?:
      | (
          | {
              gvk: {
                group: string;
                kind: string;
                version: string;
              };
              name: string;
              namespace: string;
              output_field_name: string;
              status_completed_field_name: string;
            }[]
          | null
        )
      | undefined;
    eks_addons_variables: {
      add_ons_path_prefix: string;
      add_ons_repo_url: string;
      add_ons_ssh_key: string;
      add_ons_target_revision: string;
    };
    eks_appthrust_variables: {
      appthrust_backend_image_repository: string;
      appthrust_cloud_api_url: string;
      appthrust_default_domain?: (string | null) | undefined;
      appthrust_frontend_image_repository: string;
      appthrust_image_tag: string;
      appthrust_installer_iam_role_name_override?: (string | null) | undefined;
      appthrust_keycloak_jwks_path: string;
      appthrust_organization_id: number;
      appthrust_registry: string;
      appthrust_route53_zone_delegation_iam_role_name?: (string | null) | undefined;
      appthrust_tfstate_s3_bucket_name?: (string | null) | undefined;
      enable_appthrust: boolean;
    };
    eks_auth_variables: {
      cluster_read_only_group_name: string;
      k8s_master_iam_user_arns: string[];
      k8s_namespace_admin_iam_user_arns: {
        [key: string]: string[];
      };
      k8s_read_only_iam_user_arns: string[];
    };
    eks_default_worker_node_variables: {
      cpu_architecture: string;
      karpenter_capacity_types: string[];
      karpenter_provisioner_resource_limits: {
        [key: string]: string;
      };
      managed_nodegroup_capacity_type: string;
      os: string;
      terraform_runtime_cpu_architecture: string;
    };
    eks_dns_record_behaviour_variables: {
      ttl: number;
    };
    eks_dns_variables: {
      additional_domains: string[];
      dns_suffix: string;
      enable_external_dns: boolean;
      primary_domain: string;
    };
    eks_endpoint_variables: {
      cluster_endpoint_public_access_cidrs: string[];
    };
    eks_logging_variables: {
      cluster_enabled_log_types: string[];
      log_s3_bucket_name: string;
    };
    eks_managed_node_variables: {
      dedicated_core_node_instance_types: string[];
      dedicated_core_node_num: number;
      dedicated_tekton_node_instance_types: string[];
      dedicated_tekton_node_num: number;
      dedicated_tf_node_instance_types: string[];
      dedicated_tf_node_num: number;
    };
    eks_mesh_variables: {
      cilium_version: string;
      clustermesh_apiserver_service_type: string;
      enable_clustermesh_apiserver: string;
      enable_gateway_api: boolean;
      ipam_mode: string;
      mesh_network_id: number;
    };
    eks_network_variables: {
      network_base_position: number;
      number_of_network: number;
      private_subnet_ids: string[];
      public_subnet_ids: string[];
    };
    eks_pod_spec_variables: {
      enable_pod_resource_management: boolean;
      ha_replicas: number;
    };
    eks_waf_variables: {
      waf_acl_name: string;
    };
    pending?: (boolean | null) | undefined;
    variables: {
      appthrust_kind: string;
      aws_external_id: string;
      cluster_id: number;
      cluster_name: string;
      infrastructure_id: number;
      region: string;
      tags?:
        | ({
            [key: string]: string;
          } | null)
        | undefined;
    };
  };
  status?:
    | ({
        delegated_resource_name?: (string | null) | undefined;
        driver_completed?: (boolean | null) | undefined;
        driver_delegated?: (boolean | null) | undefined;
        network_calculation_resource_name?: (string | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1EksList = {
  apiVersion?: string | undefined;
  items: Eks[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type HttprouteToIngress = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    gateway_name: string;
    ingress_name: string;
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1HttprouteToIngressList = {
  apiVersion?: string | undefined;
  items: HttprouteToIngress[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type IamData = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    assume_role_arn: string;
    aws_external_id: string;
    region: string;
  };
  status?:
    | ({
        roles?:
          | (
              | {
                  arn: string;
                  path: string;
                  role_id: string;
                  role_name: string;
                  tags: {
                    key: string;
                    value: string;
                  }[];
                }[]
              | null
            )
          | undefined;
        roles_error?: (string | null) | undefined;
        users?:
          | (
              | {
                  arn: string;
                  path: string;
                  tags: {
                    key: string;
                    value: string;
                  }[];
                  user_id: string;
                  user_name: string;
                }[]
              | null
            )
          | undefined;
        users_error?: (string | null) | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1IamDataList = {
  apiVersion?: string | undefined;
  items: IamData[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type Iam = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    dependencies?:
      | (
          | {
              gvk: {
                group: string;
                kind: string;
                version: string;
              };
              name: string;
              namespace: string;
              output_field_name: string;
              status_completed_field_name: string;
            }[]
          | null
        )
      | undefined;
    variables?:
      | ({
          assume_role_arn?: (string | null) | undefined;
          aws_external_id?: (string | null) | undefined;
          infrastructure_id?: (string | null) | undefined;
          prefix?: (string | null) | undefined;
          read_only_iam_user_names?: (string[] | null) | undefined;
          region?: (string | null) | undefined;
        } | null)
      | undefined;
  };
  status?:
    | ({
        delegated_resource_name?: (string | null) | undefined;
        driver_completed?: (boolean | null) | undefined;
        driver_delegated?: (boolean | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1IamList = {
  apiVersion?: string | undefined;
  items: Iam[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type KeycloakClientSecret = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    client_id: string;
    realm: string;
    secret_key: string;
    secret_name: string;
  };
  status?:
    | ({
        created: boolean;
      } | null)
    | undefined;
};
export type DevAppthrustV1KeycloakClientSecretList = {
  apiVersion?: string | undefined;
  items: KeycloakClientSecret[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type KeycloakKeyId = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    realm: string;
    secret_name: string;
  };
  status?:
    | ({
        created: boolean;
      } | null)
    | undefined;
};
export type DevAppthrustV1KeycloakKeyIdList = {
  apiVersion?: string | undefined;
  items: KeycloakKeyId[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type KeycloakPasswordInit = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    secret_name: string;
  };
  status?:
    | ({
        created: boolean;
      } | null)
    | undefined;
};
export type DevAppthrustV1KeycloakPasswordInitList = {
  apiVersion?: string | undefined;
  items: KeycloakPasswordInit[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type IoK8SApimachineryPkgApisMetaV1StatusCause = {
  field?: string | undefined;
  message?: string | undefined;
  reason?: string | undefined;
};
export type IoK8SApimachineryPkgApisMetaV1StatusDetails = {
  causes?: IoK8SApimachineryPkgApisMetaV1StatusCause[] | undefined;
  group?: string | undefined;
  kind?: string | undefined;
  name?: string | undefined;
  retryAfterSeconds?: number | undefined;
  uid?: string | undefined;
};
export type IoK8SApimachineryPkgApisMetaV1Status = {
  apiVersion?: string | undefined;
  code?: number | undefined;
  details?: IoK8SApimachineryPkgApisMetaV1StatusDetails | undefined;
  kind?: string | undefined;
  message?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
  reason?: string | undefined;
  status?: string | undefined;
};
export type IoK8SApimachineryPkgApisMetaV1Preconditions = {
  resourceVersion?: string | undefined;
  uid?: string | undefined;
};
export type IoK8SApimachineryPkgApisMetaV1DeleteOptions = {
  apiVersion?: string | undefined;
  dryRun?: string[] | undefined;
  gracePeriodSeconds?: number | undefined;
  kind?: string | undefined;
  orphanDependents?: boolean | undefined;
  preconditions?: IoK8SApimachineryPkgApisMetaV1Preconditions | undefined;
  propagationPolicy?: string | undefined;
};
export type NextAuthSecretRequest = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    secret_name: string;
  };
  status?:
    | ({
        created: boolean;
      } | null)
    | undefined;
};
export type DevAppthrustV1NextAuthSecretRequestList = {
  apiVersion?: string | undefined;
  items: NextAuthSecretRequest[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type Project = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    name: string;
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1ProjectList = {
  apiVersion?: string | undefined;
  items: Project[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type ReleaseChannel = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    deployment_strategy: string;
    name: string;
    project_id: string;
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1ReleaseChannelList = {
  apiVersion?: string | undefined;
  items: ReleaseChannel[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type ResourceValueSync = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    data_sources: {
      [key: string]: {
        ref: {
          group: string;
          kind: string;
          name: string;
          namespace: string;
          version: string;
        };
        type: 'KubernetesResource';
      };
    };
    sync_configs: {
      [key: string]: {
        datasource: string;
        from_path: string;
        target: {
          ref: {
            group: string;
            kind: string;
            name: string;
            namespace: string;
            version: string;
          };
          type: 'ArgocdAppHelm';
        };
        to_path: string;
      };
    };
  };
  status?:
    | ({
        sync_statuses: {
          [key: string]: {
            completed: boolean;
          };
        };
      } | null)
    | undefined;
};
export type DevAppthrustV1ResourceValueSyncList = {
  apiVersion?: string | undefined;
  items: ResourceValueSync[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type TfApply = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    destroy?: (boolean | null) | undefined;
    force_reapply?: (boolean | null) | undefined;
    pending?: (boolean | null) | undefined;
    ssh_credentials?:
      | ({
          secret_key_name: string;
          secret_name: string;
          secret_namespace: string;
        } | null)
      | undefined;
    terraform_dir?: (string | null) | undefined;
    terraform_git_repository?: (string | null) | undefined;
    terraform_git_revision?: (string | null) | undefined;
    use_ssh?: (boolean | null) | undefined;
    variables_set?:
      | ({
          [key: string]: {
            [key: string]: string;
          };
        } | null)
      | undefined;
  };
  status?:
    | ({
        completed?: (boolean | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
        state?:
          | (('Prepare' | 'PreparationFailed' | 'NotApplied' | 'Applying' | 'AppliedSuccessfully' | 'Failed') | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1TfApplyList = {
  apiVersion?: string | undefined;
  items: TfApply[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type TrafficSplitting = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    project_id: string;
    release_channel_id: string;
    traffics: {
      percent_x10000: number;
      revision?: (number | null) | undefined;
      type: 'RevisionNumber' | 'LatestRevision';
    }[];
    web_app_component_gateway_connection_ref: {
      group: string;
      kind: string;
      name: string;
      namespace: string;
      version: string;
    };
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1TrafficSplittingList = {
  apiVersion?: string | undefined;
  items: TrafficSplitting[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type VpcData = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    assume_role_arn: string;
    aws_external_id: string;
    region: string;
  };
  status?:
    | ({
        list?:
          | (
              | {
                  cidr_block: string;
                  subnets: {
                    cidr_block: string;
                    subnet_id: string;
                  }[];
                  vpc_id: string;
                }[]
              | null
            )
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1VpcDataList = {
  apiVersion?: string | undefined;
  items: VpcData[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type Vpc = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    dependencies?:
      | (
          | {
              gvk: {
                group: string;
                kind: string;
                version: string;
              };
              name: string;
              namespace: string;
              output_field_name: string;
              status_completed_field_name: string;
            }[]
          | null
        )
      | undefined;
    network_segments: number[][];
    organization_name: string;
    private_subnet_cidrs: string[];
    public_subnet_cidrs: string[];
    variables: {
      assume_role_arn: string;
      aws_external_id: string;
      black_domain_list?: (string[] | null) | undefined;
      cloudtrail_s3_bucket_name: string;
      infrastructure_id: string;
      is_multi_region_trail: boolean;
      log_s3_bucket_name: string;
      prefix: string;
      primary_cidr_block: string;
      region: string;
      secondary_cidr_blocks?: (string[] | null) | undefined;
      single_nat_gateway: boolean;
    };
  };
  status?:
    | ({
        delegated_resource_name?: (string | null) | undefined;
        driver_completed?: (boolean | null) | undefined;
        driver_delegated?: (boolean | null) | undefined;
        network_calculation_resource_name?: (string | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1VpcList = {
  apiVersion?: string | undefined;
  items: Vpc[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type Waf = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    dependencies?:
      | (
          | {
              gvk: {
                group: string;
                kind: string;
                version: string;
              };
              name: string;
              namespace: string;
              output_field_name: string;
              status_completed_field_name: string;
            }[]
          | null
        )
      | undefined;
    variables: {
      aws_account_id: string;
      aws_external_id: string;
      role_name: string;
      waf_acl_name: string;
    };
  };
  status?:
    | ({
        delegated_resource_name?: (string | null) | undefined;
        driver_completed?: (boolean | null) | undefined;
        driver_delegated?: (boolean | null) | undefined;
        outputs?:
          | ({
              [key: string]: {
                [key: string]: any;
              };
            } | null)
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1WafList = {
  apiVersion?: string | undefined;
  items: Waf[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponentBuildFinished = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    branch: string;
    container_image_tag_id: string;
    container_image_tag_snapshot: {
      container_repository_id: string;
      name: string;
    };
    container_repository_snapshot: {
      domain: string;
      git_repository_id: string;
      id: string;
      name: string;
      root_directory: string;
      type: 'EcrLocal';
    };
    deployment_id: string;
    pipeline_id: string;
    project_id: string;
    runtime_environment_variables_id: string;
    web_app_component_snapshot: {
      default_build_config: {
        branch: string;
        root_directory: string;
      };
      domains: {
        domain_id: string;
        release_channel_id: string;
        subdomain: string;
      }[];
      git_repository_id: string;
      name: string;
      project_id: string;
    };
  };
  status?:
    | ({
        state: 'WaitForRevisionResource' | 'RevisionResourceCreated';
      } | null)
    | undefined;
};
export type DevAppthrustV1WebAppComponentBuildFinishedList = {
  apiVersion?: string | undefined;
  items: WebAppComponentBuildFinished[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponentBuild = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    branch: string;
    build_time_environment_variables_id: string;
    component_id: string;
    container_image_tag_id: string;
    container_image_tag_snapshot: {
      container_repository_id: string;
      name: string;
    };
    container_repository_snapshot: {
      domain: string;
      git_repository_id: string;
      id: string;
      name: string;
      root_directory: string;
      type: 'EcrLocal';
    };
    deployment_id: string;
    git_commit_hash: string;
    pipeline_id: string;
    project_id: string;
    release_channel_id: string;
    root_directory: string;
    runtime_environment_variables_id: string;
    web_app_component_snapshot: {
      default_build_config: {
        branch: string;
        root_directory: string;
      };
      domains: {
        domain_id: string;
        release_channel_id: string;
        subdomain: string;
      }[];
      git_repository_id: string;
      name: string;
      project_id: string;
    };
  };
  status?:
    | ({
        created_at?: (string | null) | undefined;
        finished_at?: (string | null) | undefined;
        is_success?: (boolean | null) | undefined;
        logs?: (string | null) | undefined;
        message?: (string | null) | undefined;
        reason?: (string | null) | undefined;
        started_at?: (string | null) | undefined;
        state?: (('WaitingForPipelineRunResource' | 'PipelineRunDelegated' | 'PipelineRunFinished') | null) | undefined;
        updated_at?: (string | null) | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1WebAppComponentBuildList = {
  apiVersion?: string | undefined;
  items: WebAppComponentBuild[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponentDeployment = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    branch: string;
    component_id: string;
    deployment_strategy: string;
    parent_ref: {
      name: string;
      namespace: string;
    };
    project_id: string;
    release_channel_id: string;
  };
  status?:
    | ({
        conditions?: (any[] | null) | undefined;
        revision?: (number | null) | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1WebAppComponentDeploymentList = {
  apiVersion?: string | undefined;
  items: WebAppComponentDeployment[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponentGatewayConnection = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    component_id: string;
    gateway_refs: {
      group: string;
      kind: string;
      name: string;
      namespace: string;
      version: string;
    }[];
    project_id: string;
    release_channel_id: string;
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1WebAppComponentGatewayConnectionList = {
  apiVersion?: string | undefined;
  items: WebAppComponentGatewayConnection[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponentPipeline = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    branch: string;
    build_skip: boolean;
    build_time_environment_variables_id: string;
    component_id: string;
    container_image_tag_id: string;
    container_repository_id: string;
    git_commit_hash: string;
    project_id: string;
    release_channel_id: string;
    root_directory: string;
    runtime_environment_variables_id: string;
  };
  status?:
    | ({
        build_id?: (string | null) | undefined;
        build_state?: (('Skipped' | 'WaitingForBuildResource' | 'Building' | 'Finished') | null) | undefined;
        deployment_id?: (string | null) | undefined;
        is_success?: (boolean | null) | undefined;
        revision_id?: (string | null) | undefined;
        revision_state?:
          | (
              | (
                  | 'WaitingForRevisionResource'
                  | 'DeploymentNotFoundByNamespaceAndDiscriminator'
                  | 'DeploymentExistsByNamespaceAndDiscriminator'
                  | 'DeploymentNameDecided'
                  | 'AwaitDeploymentDiscrimination'
                  | 'DeploymentExistsByTrueDiscriminatedLabel'
                  | 'Provisioning'
                  | 'Finished'
                )
              | null
            )
          | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1WebAppComponentPipelineList = {
  apiVersion?: string | undefined;
  items: WebAppComponentPipeline[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponentReleaseChannelBuildConfig = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    branch?: (string | null) | undefined;
    component_id: string;
    deployment_strategy: 'Production' | 'Development';
    project_id: string;
    release_channel_id: string;
    root_directory: string;
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1WebAppComponentReleaseChannelBuildConfigList = {
  apiVersion?: string | undefined;
  items: WebAppComponentReleaseChannelBuildConfig[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponentRevision = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    branch: string;
    component_id: string;
    container_image_tag_id: string;
    container_image_tag_snapshot: {
      container_repository_id: string;
      name: string;
    };
    container_repository_snapshot: {
      domain: string;
      git_repository_id: string;
      id: string;
      name: string;
      root_directory: string;
      type: 'EcrLocal';
    };
    deployment_ref: {
      api_version: string;
      block_owner_deletion?: (boolean | null) | undefined;
      controller?: (boolean | null) | undefined;
      kind: string;
      name: string;
      uid: string;
    };
    deployment_strategy: string;
    project_id: string;
    release_channel_id: string;
    revision?: (number | null) | undefined;
    runtime_environment_variables_id: string;
  };
  status?:
    | ({
        conditions?: (any[] | null) | undefined;
        created_at?: (string | null) | undefined;
        finished_at?: (string | null) | undefined;
        is_success?: (boolean | null) | undefined;
        knative_revision_name?: (string | null) | undefined;
        knative_service_name?: (string | null) | undefined;
      } | null)
    | undefined;
};
export type DevAppthrustV1WebAppComponentRevisionList = {
  apiVersion?: string | undefined;
  items: WebAppComponentRevision[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};
export type WebAppComponent = {
  apiVersion?: string | undefined;
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ObjectMeta | undefined;
  spec: {
    default_build_config: {
      branch: string;
      root_directory: string;
    };
    domains: {
      domain_id: string;
      release_channel_id: string;
      subdomain: string;
    }[];
    git_repository_id: string;
    name: string;
    project_id: string;
  };
  status?: (object | null) | undefined;
};
export type DevAppthrustV1WebAppComponentList = {
  apiVersion?: string | undefined;
  items: WebAppComponent[];
  kind?: string | undefined;
  metadata?: IoK8SApimachineryPkgApisMetaV1ListMeta | undefined;
};

`;
